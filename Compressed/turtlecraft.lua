if (turtlecraft ~= nil) then error("A conflicting version of turtle craft exists or another script has registered 'turtlecraft'"); end turtlecraft = {}; turtlecraft.version = 0.01; turtlecraft.directory = "turtlecraft_data/"; if (not fs.exists("turtlecraft_data")) then fs.makeDir("turtlecraft_data"); end turtlecraft.math = {}; turtlecraft.math.round = function(number) if (number % 1 < 0.5) then return math.floor(number); else return math.ceil(number); end end turtlecraft.input = {}; turtlecraft.input.readKey = function() local event, code = os.pullEvent("key"); if (event ~= "key") then return nil; end return code; end turtlecraft.position = {}; (function() local directions = { north = 270, south = 90, west = 180, east = 0, up = 'up', down = 'down' }; turtlecraft.position.directions = directions; local facings = {}; facings[0] = directions.south; facings[1] = directions.west; facings[2] = directions.north; facings[3] = directions.east; turtlecraft.position.facings = facings; local location = { x = 0, y = 0, z = 0, d = directions.north }; local addons = { positionConfirmed = false, directionConfirmed = false, canSync = false, inSync = false, }; local cache = { path = turtlecraft.directory .. "position.data" }; cache.read = function() local default = { x = location.x, y = location.y, z = location.z, d = location.d, positionConfirmed = false, directionConfirmed = false }; if (not fs.exists(cache.path)) then return default; end local handle = fs.open(cache.path, "r"); if (handle == nil) then return default; end local line1 = handle.readLine(); local line2 = handle.readLine(); handle.close(); if (line1 == nil) then return default; end local reader = string.gmatch(line1, "[^,]+"); local intended = { x = tonumber(reader()), y = tonumber(reader()), z = tonumber(reader()), d = tonumber(reader()), positionConfirmed = false, directionConfirmed = false }; local fuel = tonumber(reader()); if (line2 == nil) then intended.positionConfirmed = true; intended.directionConfirmed = true; return intended; end reader = string.gmatch(line2, "[^,]+"); local previous = { x = tonumber(reader()), y = tonumber(reader()), z = tonumber(reader()), d = tonumber(reader()) }; if (fuel > turtle.getFuelLevel()) then intended.positionConfirmed = true; intended.directionConfirmed = true; elseif (fuel == turtle.getFuelLevel()) then intended.x = previous.x; intended.y = previous.y; intended.z = previous.z; intended.positionConfirmed = true; intended.directionConfirmed = intended.d == previous.d; end return intended; end cache.write = function(intended, previous) local handle = fs.open(cache.path, "w"); if (handle == nil) then return false; end handle.writeLine(intended.x .. "," .. intended.y .. "," .. intended.z .. "," .. intended.d .. "," .. turtle.getFuelLevel()); if (previous ~= nil) then handle.writeLine(previous.x .. "," .. previous.y .. "," .. previous.z .. "," .. previous.d); end handle.close(); return true; end addons.getPeripheral = function(ptype) local names = peripheral.getNames(); for i, name in pairs(names) do if (peripheral.getType(name) == ptype) then local instance = peripheral.wrap(name); return instance; end end return nil; end addons.tryUpdateCustom = function() return false; end addons.tryReadGps = function() local side = ""; if (peripheral.getType("right") == "modem") then side = "right"; end if (peripheral.getType("left") == "modem") then side = "left"; end if (side == "") then return nil; end rednet.open(side); if (not rednet.isOpen(side)) then return nil; end local x, z, y = gps.locate(10); return x, y, z; end addons.tryUpdateGps = function() local x, y, z = addons.tryReadGps(); if (x == nil) then return false; end location.x = x; location.y = y; location.z = z; addons.positionConfirmed = true; addons.canSync = true; return true; end addons.tryUpdateCompass = function() local compass = addons.getPeripheral("compass"); if (compass == nil or compass.getFacing == nil) then return false; end location.d = facings[compass.getFacing()]; addons.directionConfirmed = true; return true; end addons.trySync = function() if (addons.directionConfirmed and addons.positionConfirmed) then return true; end if (not addons.canSync) then return false; end for turns = 1, 4 do if (not turtle.detect()) then break; end location.d = (location.d + 90) % 360; turtle.turnRight(); end if (turtle.detect()) then return false; end turtle.forward(); local x = location.x; local y = location.y; local z = location.z; local d = location.d; if (d == directions.north) then y = y + 1; end if (d == directions.south) then y = y - 1; end if (d == directions.east) then x = x + 1; end if (d == directions.west) then x = x - 1; end local xx, yy, zz = addons.tryReadGps(); if (d == directions.north and xx < x) then d = directions.west; end if (d == directions.south and xx < x) then d = directions.west; end if (d == directions.east and xx < x and yy == y) then d = directions.west; end if (d == directions.north and xx > x) then d = directions.east; end if (d == directions.south and xx > x) then d = directions.east; end if (d == directions.west and xx > x and yy == y) then d = directions.east; end if (d == directions.north and yy < y and xx == x) then d = directions.south; end if (d == directions.west and yy < y) then d = directions.south; end if (d == directions.east and yy < y) then d = directions.south; end if (d == directions.south and yy > y and xx == x) then d = directions.north; end if (d == directions.west and yy > y) then d = directions.north; end if (d == directions.east and yy > y) then d = directions.north; end turtle.back(); location.d = d; cache.write(location); return true; end location.init = function() local recovery = cache.read(); location.x = recovery.x; location.y = recovery.y; location.z = recovery.z; location.d = recovery.d; addons.positionConfirmed = recovery.positionConfirmed; addons.directionConfirmed = recovery.directionConfirmed; if (not addons.tryUpdateCustom()) then addons.tryUpdateGps(); addons.tryUpdateCompass(); end addons.inSync = (addons.positionConfirmed and addons.directionConfirmed) or addons.trySync(); end location.init(); turtlecraft.position.isInSync = function() return addons.inSync; end turtlecraft.position.syncTo = function(x, y, z, d) location.x = x; location.y = y; location.z = z; location.d = d; addons.inSync = true; end turtlecraft.position.get = function() return location.x, location.y, location.z, location.d; end turtlecraft.position.set = function(x, y, z, d, moveAction) if (type(d) ~= "number") then d = location.d; end local previous = {x = location.x, y = location.y, z = location.z, d = location.d}; local intended = {x = x, y = y, z = z, d = d}; cache.write(intended, previous); if (moveAction == nil or moveAction() == false) then return false; end cache.write(intended); location.x = x; location.y = y; location.z = z; location.d = d; return true; end end)(); turtlecraft.fuel = {}; (function() local internal = { fuelSlot = 1, fuelPerBurn = 0, itemsPerBurn = 1 }; internal.getRefuelCount = function() return turtle.getItemCount(internal.fuelSlot); end internal.burn = function() turtle.select(internal.fuelSlot); local preburn = turtle.getFuelLevel(); if (not turtle.refuel(internal.itemsPerBurn)) then return false; end local postburn = turtle.getFuelLevel(); internal.fuelPerBurn = postburn - preburn; return true; end turtlecraft.fuel.estimateRemaining = function() local current = turtle.getFuelLevel(); local refuels = internal.getRefuelCount(); local unburned = refuels * internal.fuelPerBurn; return current + unburned; end turtlecraft.fuel.require = function(count) if (count == nil) then count = 1; end while (turtle.getFuelLevel() < count) do if (not internal.burn()) then print("Turtle ran out of fuel! Please put more in slot 1"); while (not internal.burn()) do sleep(5); end end end end end)();turtlecraft.move = {}; (function() local internal = {}; local directions = turtlecraft.position.directions; internal.face = function(direction) if (direction == directions.up or direction == directions.down) then return true; end local x, y, z, d = turtlecraft.position.get(); if (d == direction) then return true; end if (d % 90 ~= 0) then error("Facing directions must be multiples of 90 degrees"); end if ((d + 270) % 360 == direction) then turtlecraft.position.set(x, y, z, direction, turtle.turnLeft); else while (d ~= direction) do d = (d + 90) % 360; turtlecraft.position.set(x, y, z, d, turtle.turnRight); end end return true; end internal.dig = function() return (not turtle.detect()) or turtle.dig(); end internal.digUp = function() return (not turtle.detectUp()) or turtle.digUp(); end internal.digDown = function() return (not turtle.detectDown()) or turtle.digDown(); end internal.excavate = function() internal.digUp(); internal.digDown(); return internal.dig(); end internal.excavateUp = function() internal.dig(); internal.digDown(); return internal.digUp(); end internal.excavateDown = function() internal.dig(); internal.digUp(); return internal.digDown(); end internal.move = function(direction, before, after, onRetry) local move = turtle.forward; if (direction == directions.up) then move = turtle.up; end if (direction == directions.down) then move = turtle.down; end local x, y, z, d = turtlecraft.position.get(); if (direction == directions.up) then z = z + 1; end if (direction == directions.down) then z = z - 1; end if (direction == directions.north) then y = y + 1; end if (direction == directions.south) then y = y - 1; end if (direction == directions.east) then x = x + 1; end if (direction == directions.west) then x = x - 1; end local action = function() turtlecraft.fuel.require(1); while (not move()) do if (onRetry ~= nil and onRetry(direction) == false) then return false; end sleep(.01); end return true; end internal.face(direction); if (before ~= nil and before(direction) == false) then return false; end if (turtlecraft.position.set(x, y, z, direction, action) == false) then return false; end if (after ~= nil and after(direction) == false) then return false; end return true; end internal.repeatMove = function(from, to, directionMore, directionLess, before, after, onRetry) local count = to - from; local direction = directionMore; if (count < 0) then direction = directionLess; end for i = 1, math.abs(count) do if (internal.move(direction, before, after, onRetry) == false) then return false; end end return true; end internal.moveTo = function(x, y, z, before, after, onRetry) local px, py, pz, pd = turtlecraft.position.get(); if (internal.repeatMove(px, x, directions.east, directions.west, before, after, onRetry) == false) then return false; end if (internal.repeatMove(py, y, directions.north, directions.south, before, after, onRetry) == false) then return false; end if (internal.repeatMove(pz, z, directions.up, directions.down, before, after, onRetry) == false) then return false; end return true; end turtlecraft.move.face = function(direction) return internal.face(direction); end turtlecraft.move.to = function(x, y, z, action) return internal.moveTo(x, y, z, nil, action, nil); end turtlecraft.move.digTo = function(x, y, z, action) local dig = function(direction) if (direction == directions.up) then return internal.digUp(); elseif (direction == directions.down) then return internal.digDown(); else return internal.dig(); end end return internal.moveTo(x, y, z, dig, action, dig); end turtlecraft.move.excavateTo = function(x, y, z, action) local dig = function(direction) if (direction == directions.up) then return internal.excavateUp(); elseif (direction == directions.down) then return internal.excavateDown(); else return internal.excavate(); end end return internal.moveTo(x, y, z, dig, action, dig); end end)(); turtlecraft.excavate = {}; (function() local position = turtlecraft.position; local directions = position.directions; local inventory = {}; local plot = {}; local move = {}; local ui = {}; plot.path = turtlecraft.directory .. "excavate.data"; plot.init = function(forward, left, right, up, down) local x, y, z, d = position.get(); plot.home = {x = x, y = y, z = z, d = (d + 180) % 360}; plot.step = {x = 1, y = 1, z = -3}; plot.min = {x = x, y = y, z = z - math.abs(down) + 1}; plot.max = {x = x, y = y, z = z + math.abs(up) - 1}; if (d == directions.north) then plot.max.y = plot.max.y + math.abs(forward); plot.min.x = plot.min.x - math.abs(left); plot.max.x = plot.max.x + math.abs(right); elseif (d == directions.south) then plot.min.y = plot.min.y - math.abs(forward); plot.min.x = plot.min.x - math.abs(right); plot.max.x = plot.max.x + math.abs(left); elseif (d == directions.east) then plot.max.x = plot.max.x + math.abs(forward); plot.min.y = plot.min.y - math.abs(right); plot.max.y = plot.max.y + math.abs(left); else plot.min.x = plot.min.x - math.abs(forward); plot.min.y = plot.min.y - math.abs(left); plot.max.y = plot.max.y + math.abs(right); end plot.progress = {x = plot.min.x, y = plot.min.y, z = plot.max.z}; end plot.update = function() local x, y, z, d = position.get(); plot.progress = {x = x, y = y, z = z}; local file = fs.open(plot.path, "w"); file.writeLine(plot.home.x .. "," .. plot.home.y .. "," .. plot.home.z .. "," .. plot.home.d); file.writeLine(x .. "," .. y .. "," .. z); file.writeLine(plot.min.x .. "," .. plot.min.y .. "," .. plot.min.z); file.writeLine(plot.max.x .. "," .. plot.max.y .. "," .. plot.max.z); file.writeLine(plot.step.x .. "," .. plot.step.y .. "," .. plot.step.z); file.close(); end plot.reset = function() fs.delete(plot.path); local x, y, z, d = position.get(); plot.home = {x = x, y = y, z = z, d = (d + 180) % 360}; plot.progress = {x = x, y = y, z = z}; plot.min = {x = x, y = y, z = z}; plot.max = {x = x, y = y, z = z}; plot.step = {x = 1, y = 1, z = -3}; end plot.recover = function() if (not fs.exists(plot.path)) then return false; end local file = fs.open(plot.path, "r"); local home = file.readLine(); local progress = file.readLine(); local boundsmin = file.readLine(); local boundsmax = file.readLine(); local resume = file.readLine(); file.close(); if ((not position.isInSync()) or home == nil or progress == nil or boundsmin == nil or boundsmax == nil or resume == nil) then print("Warning: Unable to resume dig"); return false; end local valuePattern = "[^,]+"; local setters = { home = home, progress = progress, min = boundsmin, max = boundsmax, step = resume }; for index, data in pairs(setters) do local reader = string.gmatch(data, valuePattern); local target = plot[index]; target.x = tonumber(reader() or 0); target.y = tonumber(reader() or 0); target.z = tonumber(reader() or 0); target.d = tonumber(reader() or ""); end return true; end plot.calcDistance = function(x, y, z) local fx, fy, fz, fd = position.get(); local distx = math.abs(fx - x); local disty = math.abs(fy - y); local distz = math.abs(fz - z); return distx + disty + distz + 5; end plot.calcReturn = function() return plot.calcDistance(plot.home.x, plot.home.y, plot.home.z); end inventory.calcRemainingSlots = function() local count = 0; for i = 2, 16 do if (turtle.getItemCount(i) == 0) then count = count + 1; end end return count; end inventory.needsUnload = function() return inventory.calcRemainingSlots() == 0; end inventory.unload = function() turtlecraft.move.face(plot.home.d); for i = 2, 16 do if (turtle.getItemCount(i) > 0) then turtle.select(i); if (not turtle.drop()) then error("Fatal Error: Can't unload inventory."); end end end end move.home = function(callback) turtlecraft.move.digTo(plot.home.x, plot.home.y, plot.home.z); callback(); turtlecraft.move.face((plot.home.d + 180) % 360); turtlecraft.move.digTo(plot.progress.x, plot.progress.y, plot.progress.z); end move.finish = function() turtlecraft.move.digTo(plot.home.x, plot.home.y, plot.home.z); turtlecraft.move.face(plot.home.d); inventory.unload(); turtle.select(1); turtle.drop(); turtlecraft.move.face((plot.home.d + 180) % 360); plot.reset(); end move.next = function() local resumeDist = plot.calcDistance(plot.progress.x, plot.progress.y, plot.progress.z); local homeDist = plot.calcReturn(); local fuel = turtlecraft.fuel.estimateRemaining(); if (inventory.needsUnload() or fuel <= resumeDist or fuel <= homeDist) then move.home(function() local distance = plot.calcDistance(plot.progress.x, plot.progress.y, plot.progress.z); turtlecraft.fuel.require(distance); inventory.unload(); end); end if (not turtlecraft.move.digTo(plot.progress.x, plot.progress.y, plot.progress.z)) then move.finish(); return false; end plot.progress.x = plot.progress.x + plot.step.x; if (plot.progress.x > plot.max.x or plot.progress.x < plot.min.x) then plot.step.x = -plot.step.x; plot.progress.x = plot.progress.x + plot.step.x; plot.progress.y = plot.progress.y + plot.step.y; if (plot.progress.y > plot.max.y or plot.progress.y < plot.min.y) then plot.step.y = -plot.step.y; plot.progress.y = plot.progress.y + plot.step.y; plot.progress.z = plot.progress.z + plot.step.z; if (plot.progress.z == plot.min.z - 1 or plot.progress.z == plot.min.z - 2) then plot.progress.z = plot.min.z; end if (plot.progress.z < plot.min.z) then move.finish(); return false; end end end if (not turtlecraft.move.excavateTo(plot.progress.x, plot.progress.y, plot.progress.z)) then move.finish(); return false; end plot.update(); return true; end move.start = function(forward, left, right, up, down) plot.init(forward, left, right, up, down); while (move.next()) do sleep(0.001); end end ui.print = function(x, y, message) term.setCursorPos(x, y); term.clearLine(); term.write(message); end ui.readNumber = function(x, y) term.setCursorPos(x, y); local value = tonumber(read() or ""); if (value == nil) then return 0; end return value; end ui.printHeader = function() ui.print(1, 1, "Turtlecraft v" .. turtlecraft.version .. " Excavator"); ui.print(1, 2, "============================"); print(""); end if (plot.recover()) then term.clear(); ui.printHeader(); ui.print(1, 3, "Resuming dig..."); while (move.next()) do sleep(0.001); end end turtlecraft.excavate.start = function() term.clear(); ui.printHeader(); ui.print(1, 4, "How far forward?"); local forward = ui.readNumber(18, 4); if (forward == 0) then return false; end ui.print(1, 4, "How far left?"); local left = ui.readNumber(15, 4); ui.print(1, 4, "How far right?"); local right = ui.readNumber(16, 4); if (left == 0 and right == 0) then return false; end ui.print(1, 4, "How far up?"); local up = ui.readNumber(13, 4); ui.print(1, 4, "How far down?"); local down = ui.readNumber(15, 4); if (up == 0 and down == 0) then return false; end term.clear(); ui.printHeader(); move.start(forward, left, right, up, down); term.clear(); ui.printHeader(); ui.print(1, 4, "Digging is complete."); ui.print(1, 5, "Press enter to continue."); term.setCursorPos(0, 0); read(); end turtlecraft.excavate.debug = {}; turtlecraft.excavate.debug.start = function(forward, left, right, up, down) move.start(forward, left, right, up, down); end end)(); turtlecraft.menu = {} turtlecraft.menu[1] = { title = "Dig functions", action = {}; } turtlecraft.menu[1].action = {}; turtlecraft.menu[1].action[1] = { title = "Excavate", action = turtlecraft.excavate.start }; turtlecraft.menu[1].action[2] = { title = "Eat Area", action = function() print("NYI"); read(); end }; turtlecraft.menu[1].action[3] = { title = "Fill Area", action = function() print("NYI"); read(); end }; turtlecraft.menu[1].action[4] = { title = "Empty Area", action = function() print("NYI"); read(); end }; (function() local selectedIndex = 1; local history = {}; table.insert(history, turtlecraft.menu); local writeLine = function(x, y, text) term.setCursorPos(x, y); term.clearLine(); term.write(text); end local currentMenu = function() local item = history[table.getn(history)]; return item; end local drawMenu = function() term.clear(); local width, height = term.getSize(); writeLine(1, 1, "Turtlecraft v" .. turtlecraft.version .. "."); writeLine(1, 2, "===================="); writeLine(1, height, "**Use up/down and enter/left**"); local displayCount = height - 4; local startIndex = math.max(0, selectedIndex - displayCount); local endIndex = startIndex + displayCount; local menu = currentMenu(); for index, item in ipairs(menu) do if (index > startIndex and index <= endIndex) then local text = item.title; if (index == selectedIndex) then text = ">" .. text .. "<"; else text = " " .. text; end writeLine(1, index - startIndex + 3, text); end end end local selectItem = function() local menu = currentMenu(); local item = menu[selectedIndex].action; if (type(item) == "function") then item(); else table.insert(history, item); end end local goBack = function() if (table.getn(history) > 1) then selectedIndex = 1; table.remove(history); end end local downArrow = function() local menu = currentMenu(); if (selectedIndex < table.getn(menu)) then selectedIndex = selectedIndex + 1; end end local upArrow = function() if (selectedIndex > 1) then selectedIndex = selectedIndex - 1; end end if (not turtlecraft.position.isInSync()) then term.clear(); writeLine(1, 1, "The turtle's position has gotten out of sync."); writeLine(1, 2, "If there was a function in progress it has likely been cancelled."); writeLine(1, 3, "Press any key to continue"); local _, _, _, d = turtlecraft.position.get(); turtlecraft.position.set(0, 0, 0, d); turtlecraft.input.readKey(); end while (true) do drawMenu(); sleep(0.01); local key = turtlecraft.input.readKey(); if (key == 28) then selectItem(); end if (key == 200) then upArrow(); end if (key == 208) then downArrow(); end if (key == 203) then goBack(); end end end)(); 
if turtlecraft~=nil then error("A conflicting version of turtle craft exists or another script has registered 'turtlecraft'")end;turtlecraft={}turtlecraft.version=0.01;turtlecraft.directory="turtlecraft_data/"if not fs.exists("turtlecraft_data")then fs.makeDir("turtlecraft_data")end;turtlecraft.input={}turtlecraft.input.readKey=function(a)if a~=nil then os.startTimer(a)end;local b=""local c=0;repeat b,c=os.pullEvent()until b=="key"or b=="timer"if b=="timer"then return nil end;return c end;turtlecraft.input.escapeOnKey=function(e,f)local g=function()while true do local b,c=os.pullEvent("key")if c==e then return end end end;parallel.waitForAny(g,f)end;turtlecraft.term={}turtlecraft.term.write=function(i,j,k)term.setCursorPos(i,j)term.clearLine()term.write(k)end;turtlecraft.term.clear=function(l,m)term.clear()local n,o=term.getSize()local p="Turtlecraft v"..turtlecraft.version;if l~=nil then p=p.." - "..l end;turtlecraft.term.write(1,1,p)local q=""for r=1,n do q=q.."="end;turtlecraft.term.write(1,2,q)if m~=nil then turtlecraft.term.write(1,o,m)end end;turtlecraft.term.scrolled=function(i,j,s,k)local t,o=term.getSize()local u=math.max(0,s-o+1)local w=o-5;local A=3;local position=j-u;if position<1 or position>w then return end;turtlecraft.term.write(1,position+A,k)end;turtlecraft.term.notifyResume=function(B)if B==nil then B="previous function"end;turtlecraft.term.clear()turtlecraft.term.write(1,4,"Resuming: "..B)turtlecraft.term.write(1,5,"in 15 seconds.")turtlecraft.term.write(1,6,"Press any key to cancel.")local c=turtlecraft.input.readKey(15)turtlecraft.term.clear()return c==nil end;turtlecraft.position={}function()local directions={north=270,south=90,west=180,east=0,up='up',down='down'}turtlecraft.position.directions=directions;local facings={}facings[0]=directions.south;facings[1]=directions.west;facings[2]=directions.north;facings[3]=directions.east;turtlecraft.position.facings=facings;local C={x=0,y=0,z=0,d=directions.north}local D={positionConfirmed=false,directionConfirmed=false,canSync=false,inSync=false}local E={path=turtlecraft.directory.."position.data"}E.read=function()local F={x=C.x,y=C.y,z=C.z,d=C.d,positionConfirmed=false,directionConfirmed=false}if not fs.exists(E.path)then return F end;local G=fs.open(E.path,"r")if G==nil then return F end;local H=G.readLine()local I=G.readLine()G.close()if H==nil then return F end;local J=string.gmatch(H,"[^,]+")local K={x=tonumber(J()),y=tonumber(J()),z=tonumber(J()),d=tonumber(J()),positionConfirmed=false,directionConfirmed=false}local fuel=tonumber(J())if I==nil then K.positionConfirmed=true;K.directionConfirmed=true;return K end;J=string.gmatch(I,"[^,]+")local L={x=tonumber(J()),y=tonumber(J()),z=tonumber(J()),d=tonumber(J())}if fuel>turtle.getFuelLevel()then K.positionConfirmed=true;K.directionConfirmed=true elseif fuel==turtle.getFuelLevel()then K.x=L.x;K.y=L.y;K.z=L.z;K.positionConfirmed=true;K.directionConfirmed=K.d==L.d end;return K end;E.write=function(K,L)local G=fs.open(E.path,"w")if G==nil then return false end;G.writeLine(K.x..","..K.y..","..K.z..","..K.d..","..turtle.getFuelLevel())if L~=nil then G.writeLine(L.x..","..L.y..","..L.z..","..L.d)end;G.close()return true end;D.getPeripheral=function(M)local N=peripheral.getNames()for r,O in pairs(N)do if peripheral.getType(O)==M then local P=peripheral.wrap(O)return P end end;return nil end;D.tryUpdateCustom=function()return false end;D.tryReadGps=function()local Q=""if peripheral.getType("right")=="modem"then Q="right"end;if peripheral.getType("left")=="modem"then Q="left"end;if Q==""then return nil end;rednet.open(Q)if not rednet.isOpen(Q)then return nil end;local x,z,y=gps.locate(10)return x,y,z end;D.tryUpdateGps=function()local x,y,z=D.tryReadGps()if x==nil then return false end;C.x=x;C.y=y;C.z=z;D.positionConfirmed=true;D.canSync=true;return true end;D.tryUpdateCompass=function()local R=D.getPeripheral("compass")if R==nil or R.getFacing==nil then return false end;C.d=facings[R.getFacing()]D.directionConfirmed=true;return true end;D.trySync=function()if D.directionConfirmed and D.positionConfirmed then return true end;if not D.canSync then return false end;for S=1,4 do if not turtle.detect()then break end;C.d=(C.d+90)%360;turtle.turnRight()end;if turtle.detect()then return false end;turtle.forward()local x=C.x;local y=C.y;local z=C.z;local d=C.d;if d==directions.north then y=y+1 end;if d==directions.south then y=y-1 end;if d==directions.east then x=x+1 end;if d==directions.west then x=x-1 end;local T,U,V=D.tryReadGps()if d==directions.north and T<x then d=directions.west end;if d==directions.south and T<x then d=directions.west end;if d==directions.east and T<x and U==y then d=directions.west end;if d==directions.north and T>x then d=directions.east end;if d==directions.south and T>x then d=directions.east end;if d==directions.west and T>x and U==y then d=directions.east end;if d==directions.north and U<y and T==x then d=directions.south end;if d==directions.west and U<y then d=directions.south end;if d==directions.east and U<y then d=directions.south end;if d==directions.south and U>y and T==x then d=directions.north end;if d==directions.west and U>y then d=directions.north end;if d==directions.east and U>y then d=directions.north end;turtle.back()C.d=d;E.write(C)return true end;C.init=function()local W=E.read()C.x=W.x;C.y=W.y;C.z=W.z;C.d=W.d;D.positionConfirmed=W.positionConfirmed;D.directionConfirmed=W.directionConfirmed;if not D.tryUpdateCustom()then D.tryUpdateGps()D.tryUpdateCompass()end;D.inSync=D.positionConfirmed and D.directionConfirmed or D.trySync()end;C.init()turtlecraft.position.isInSync=function()return D.inSync end;turtlecraft.position.syncTo=function(x,y,z,d)C.x=x;C.y=y;C.z=z;C.d=d;D.inSync=true end;turtlecraft.position.get=function()return C.x,C.y,C.z,C.d end;turtlecraft.position.set=function(x,y,z,d,X)if type(d)~="number"then d=C.d end;local L={x=C.x,y=C.y,z=C.z,d=C.d}local K={x=x,y=y,z=z,d=d}E.write(K,L)if X==nil or X()==false then E.write(L)return false end;E.write(K)C.x=x;C.y=y;C.z=z;C.d=d;return true end end()turtlecraft.fuel={}function()local Y={fuelSlot=1,fuelPerBurn=0,itemsPerBurn=1}Y.getRefuelCount=function()return turtle.getItemCount(Y.fuelSlot)end;Y.burn=function()turtle.select(Y.fuelSlot)local Z=turtle.getFuelLevel()if not turtle.refuel(Y.itemsPerBurn)then return false end;local _=turtle.getFuelLevel()Y.fuelPerBurn=_-Z;return true end;turtlecraft.fuel.estimateRemaining=function()local a0=turtle.getFuelLevel()local a1=Y.getRefuelCount()local a2=a1*Y.fuelPerBurn;return a0+a2 end;turtlecraft.fuel.require=function(a3)if a3==nil then a3=1 end;while turtle.getFuelLevel()<a3 do if not Y.burn()then print("Turtle ran out of fuel! Please put more in slot 1")while not Y.burn()do sleep(5)end end end end end()turtlecraft.move={}function()local Y={}local directions=turtlecraft.position.directions;Y.face=function(a4)if a4==directions.up or a4==directions.down then return true end;local x,y,z,d=turtlecraft.position.get()if d==a4 then return true end;if d%90~=0 then error("Facing directions must be multiples of 90 degrees")end;if(d+270)%360==a4 then turtlecraft.position.set(x,y,z,a4,turtle.turnLeft)else while d~=a4 do d=(d+90)%360;turtlecraft.position.set(x,y,z,d,turtle.turnRight)end end;return true end;Y.dig=function()return not turtle.detect()or turtle.dig()end;Y.digUp=function()return not turtle.detectUp()or turtle.digUp()end;Y.digDown=function()return not turtle.detectDown()or turtle.digDown()end;Y.excavate=function()Y.digUp()Y.digDown()return Y.dig()end;Y.excavateUp=function()Y.dig()Y.digDown()return Y.digUp()end;Y.excavateDown=function()Y.dig()Y.digUp()return Y.digDown()end;Y.move=function(a4,a5,a6,a7)local move=turtle.forward;if a4==directions.up then move=turtle.up end;if a4==directions.down then move=turtle.down end;local x,y,z,d=turtlecraft.position.get()if a4==directions.up then z=z+1 end;if a4==directions.down then z=z-1 end;if a4==directions.north then y=y+1 end;if a4==directions.south then y=y-1 end;if a4==directions.east then x=x+1 end;if a4==directions.west then x=x-1 end;local action=function()turtlecraft.fuel.require(1)while not move()do if a7~=nil and a7(a4)==false then return false end;sleep(.01)end;return true end;Y.face(a4)if a5~=nil and a5(a4)==false then return false end;if turtlecraft.position.set(x,y,z,a4,action)==false then return false end;if a6~=nil and a6(a4)==false then return false end;return true end;Y.repeatMove=function(a8,to,a9,aa,a5,a6,a7)local a3=to-a8;local a4=a9;if a3<0 then a4=aa end;for r=1,math.abs(a3)do if Y.move(a4,a5,a6,a7)==false then return false end end;return true end;Y.moveTo=function(x,y,z,a5,a6,a7)local ab,ac,ad,ae=turtlecraft.position.get()if Y.repeatMove(ab,x,directions.east,directions.west,a5,a6,a7)==false then return false end;if Y.repeatMove(ac,y,directions.north,directions.south,a5,a6,a7)==false then return false end;if Y.repeatMove(ad,z,directions.up,directions.down,a5,a6,a7)==false then return false end;return true end;turtlecraft.move.face=function(a4)return Y.face(a4)end;turtlecraft.move.to=function(x,y,z,action)return Y.moveTo(x,y,z,nil,action,nil)end;turtlecraft.move.digTo=function(x,y,z,action)local dig=function(a4)if a4==directions.up then return Y.digUp()elseif a4==directions.down then return Y.digDown()else return Y.dig()end end;return Y.moveTo(x,y,z,dig,action,dig)end;turtlecraft.move.excavateTo=function(x,y,z,action)local dig=function(a4)if a4==directions.up then return Y.excavateUp()elseif a4==directions.down then return Y.excavateDown()else return Y.excavate()end end;return Y.moveTo(x,y,z,dig,action,dig)end end()turtlecraft.excavate={}function()local position=turtlecraft.position;local directions=position.directions;local af=turtlecraft.term;local ag={}local ah={}local move={}ah.path=turtlecraft.directory.."excavate.data"ah.init=function(forward,ai,aj,up,down)local x,y,z,d=position.get()ah.home={x=x,y=y,z=z,d=(d+180)%360}ah.step={x=1,y=1,z=-3}ah.min={x=x,y=y,z=z-math.abs(down)+1}ah.max={x=x,y=y,z=z+math.abs(up)-1}if d==directions.north then ah.max.y=ah.max.y+math.abs(forward)ah.min.x=ah.min.x-math.abs(ai)ah.max.x=ah.max.x+math.abs(aj)elseif d==directions.south then ah.min.y=ah.min.y-math.abs(forward)ah.min.x=ah.min.x-math.abs(aj)ah.max.x=ah.max.x+math.abs(ai)elseif d==directions.east then ah.max.x=ah.max.x+math.abs(forward)ah.min.y=ah.min.y-math.abs(aj)ah.max.y=ah.max.y+math.abs(ai)else ah.min.x=ah.min.x-math.abs(forward)ah.min.y=ah.min.y-math.abs(ai)ah.max.y=ah.max.y+math.abs(aj)end;ah.progress={x=ah.min.x,y=ah.min.y,z=ah.max.z}end;ah.update=function()local x,y,z,d=position.get()ah.progress={x=x,y=y,z=z}local ak=fs.open(ah.path,"w")ak.writeLine(ah.home.x..","..ah.home.y..","..ah.home.z..","..ah.home.d)ak.writeLine(x..","..y..","..z)ak.writeLine(ah.min.x..","..ah.min.y..","..ah.min.z)ak.writeLine(ah.max.x..","..ah.max.y..","..ah.max.z)ak.writeLine(ah.step.x..","..ah.step.y..","..ah.step.z)ak.close()end;ah.reset=function()fs.delete(ah.path)local x,y,z,d=position.get()ah.home={x=x,y=y,z=z,d=(d+180)%360}ah.progress={x=x,y=y,z=z}ah.min={x=x,y=y,z=z}ah.max={x=x,y=y,z=z}ah.step={x=1,y=1,z=-3}end;ah.recover=function()if not fs.exists(ah.path)then return false end;local ak=fs.open(ah.path,"r")local al=ak.readLine()local am=ak.readLine()local an=ak.readLine()local ao=ak.readLine()local ap=ak.readLine()ak.close()if not position.isInSync()or al==nil or am==nil or an==nil or ao==nil or ap==nil then print("Warning: Unable to resume dig")return false end;local aq="[^,]+"local ar={al=al,am=am,min=an,max=ao,step=ap}for as,at in pairs(ar)do local J=string.gmatch(at,aq)if ah[as]==nil then ah[as]={}end;local au=ah[as]au.x=tonumber(J()or 0)au.y=tonumber(J()or 0)au.z=tonumber(J()or 0)au.d=tonumber(J()or"")end;fs.delete(ah.path)return true end;ah.calcDistance=function(x,y,z)local av,aw,ax,ay=position.get()local az=math.abs(av-x)local aA=math.abs(aw-y)local aB=math.abs(ax-z)return az+aA+aB+5 end;ah.calcReturn=function()return ah.calcDistance(ah.home.x,ah.home.y,ah.home.z)end;ag.calcRemainingSlots=function()local a3=0;for r=2,16 do if turtle.getItemCount(r)==0 then a3=a3+1 end end;return a3 end;ag.needsUnload=function()return ag.calcRemainingSlots()==0 end;ag.unload=function()turtlecraft.move.face(ah.home.d)for r=2,16 do if turtle.getItemCount(r)>0 then turtle.select(r)if not turtle.drop()then error("Fatal Error: Can't unload inventory.")end end end end;move.home=function(aC)turtlecraft.move.digTo(ah.home.x,ah.home.y,ah.home.z)aC()turtlecraft.move.face((ah.home.d+180)%360)turtlecraft.move.digTo(ah.progress.x,ah.progress.y,ah.progress.z)end;move.finish=function()fs.delete(ah.path)turtlecraft.move.digTo(ah.home.x,ah.home.y,ah.home.z)turtlecraft.move.face(ah.home.d)ag.unload()turtle.select(1)turtle.drop()turtlecraft.move.face((ah.home.d+180)%360)ah.reset()end;move.next=function()local aD=ah.calcDistance(ah.progress.x,ah.progress.y,ah.progress.z)local aE=ah.calcReturn()local fuel=turtlecraft.fuel.estimateRemaining()if ag.needsUnload()or fuel<=aD or fuel<=aE then move.home(function()local aF=ah.calcDistance(ah.progress.x,ah.progress.y,ah.progress.z)turtlecraft.fuel.require(aF)ag.unload()end)end;if not turtlecraft.move.digTo(ah.progress.x,ah.progress.y,ah.progress.z)then move.finish()return false end;local aG=turtlecraft.move.excavateTo;local au={x=ah.progress.x,y=ah.progress.y,z=ah.progress.z}au.x=au.x+ah.step.x;if au.x>ah.max.x or au.x<ah.min.x then ah.step.x=-ah.step.x;au.x=au.x+ah.step.x;au.y=ah.progress.y+ah.step.y;if au.y>ah.max.y or au.y<ah.min.y then ah.step.y=-ah.step.y;au.y=au.y+ah.step.y;au.z=au.z+ah.step.z;aG=turtlecraft.move.digTo;turtle.digUp()if au.z==ah.min.z-1 or au.z==ah.min.z-2 then au.z=ah.min.z end;if au.z<ah.min.z then move.finish()return false end end end;if not aG(au.x,au.y,au.z)then print("move failed")local x,y,z,d=turtlecraft.position.get()if x==ah.progress.x and y==ah.progress.y and z==ah.progress.z then print("Unable to dig further")move.finish()return false end end;ah.update()return true end;move.start=function(forward,ai,aj,up,down)ah.init(forward,ai,aj,up,down)turtlecraft.term.write(1,5,"Press Q to cancel")turtlecraft.input.escapeOnKey(16,function()while move.next()do sleep(0.001)end end)ah.reset()end;local aH=function(x,y)term.setCursorPos(x,y)local aI=tonumber(read()or"")if aI==nil then return 0 end;return aI end;if ah.recover()then if not af.notifyResume("excavating")then af.clear("Excavate")af.write(1,5,"Excavate cancelled...")sleep(3)return end;af.clear("Excavate")af.write(1,5,"Resuming excavate...")term.setCursorPos(1,6)while move.next()do sleep(0.001)end end;turtlecraft.excavate.start=function()af.clear("Excavate")af.write(1,4,"How far forward?")local forward=aH(18,4)if forward==0 then return false end;af.write(1,4,"How far left?")local ai=aH(15,4)af.write(1,4,"How far right?")local aj=aH(16,4)if ai==0 and aj==0 then return false end;af.write(1,4,"How far up?")local up=aH(13,4)af.write(1,4,"How far down?")local down=aH(15,4)if up==0 and down==0 then return false end;af.clear("Excavate")move.start(forward,ai,aj,up,down)af.clear("Excavate")af.write(1,4,"Digging is complete.")af.write(1,5,"Press any key to continue.")term.setCursorPos(0,0)turtlecraft.input.readKey(10)end;turtlecraft.excavate.debug={}turtlecraft.excavate.debug.start=function(forward,ai,aj,up,down)move.start(forward,ai,aj,up,down)end end()turtlecraft.seeker={}function()local path=turtlecraft.directory.."seeker.data"local aJ=function(action)turtle.turnRight()turtle.turnRight()local aK=action()turtle.turnRight()turtle.turnRight()return aK end;local directions={up="up",down="down",forward="forward"}local aL={turtle.turnRight,turtle.turnLeft,turtle.turnLeft,turtle.turnLeft}local E={}E.write=function(aM,a4)local ak=fs.open(path,"w")ak.write(aM..","..a4)ak.close()end;E.complete=function()fs.delete(path)end;E.read=function()if not fs.exists(path)then return nil end;local ak=fs.open(path,"r")local at=ak.readLine()ak.close()if at==nil then return nil end;local J=string.gmatch(at,"[^,]+")return J(),J()end;local aN=function()local aO=0;while true do for r=1,16 do if turtle.getItemCount(r)==0 then sleep(aO)return end end;aO=15;turtlecraft.term.clear("Inventory")turtlecraft.term.write(1,5,"Please unload me...")sleep(1)end end;local aP=function()local aO=0;while true do for r=2,16 do if turtle.getItemCount(r)>0 then sleep(aO)if turtle.getItemCount(r)>0 then turtle.select(r)return r end end end;aO=15;turtlecraft.term.clear("Inventory")turtlecraft.term.write(1,5,"Please add more inventory...")sleep(1)end end;local eat=function(compare,a4)if a4==nil then a4=directions.down;if turtle.detectUp()and not turtle.detectDown()then a4=directions.up end end;if compare and turtle.getItemCount(2)==0 then turtle.select(2)turtlecraft.fuel.require(1)if turtle.detectUp()then turtle.digUp()turtle.up()elseif turtle.detectDown()then turtle.digDown()turtle.down()else turtlecraft.term.clear()turtlecraft.term.write(1,5,"I need a sample block to unfill with.")turtlecraft.input.readKey(5)return end;E.write("unfill",a4)else E.write("eat",a4)end;local aQ=turtle.detectUp;local aR=turtle.detectDown;local aS=turtle.detect;if compare then aQ=function()turtle.select(2)return turtle.compareUp()end;aR=function()turtle.select(2)return turtle.compareDown()end;aS=function()turtle.select(2)return turtle.compare()end end;local aT={move=turtle.up,detect=aQ,dig=turtle.digUp}local am={move=turtle.down,detect=aR,dig=turtle.digDown}if a4==directions.up then aT={move=turtle.down,detect=aR,dig=turtle.digDown}am={move=turtle.up,detect=aQ,dig=turtle.digUp}end;local step=function()for r,aU in pairs(aL)do aU()if aS()then return true end end;return false end;local aV=function()aT.move()for aW=1,3 do for aX=1,4 do turtlecraft.fuel.require(2)turtle.forward()turtle.forward()if aT.detect()or am.detect()or step()then return true end;turtle.turnLeft()end;am.move()end;return false end;turtlecraft.term.clear("Munch Munch")turtlecraft.term.write(1,5,"Press Q to stop")turtlecraft.input.escapeOnKey(16,function()while true do turtlecraft.fuel.require(1)aN()if aT.detect()then aT.dig()aT.move()elseif step()then while aS()and turtle.dig()do sleep(0.5)end;turtle.forward()elseif am.detect()then while am.detect()and am.dig()do sleep(0.5)end;am.move()elseif not aV()then turtlecraft.term.clear("All Gone?")turtlecraft.term.write(1,5,"I got lost!")turtlecraft.input.readKey(10)return end end end)E.complete()end;turtlecraft.seeker.eat=function(a4)eat(false,a4)end;turtlecraft.seeker.unfill=function(a4)eat(true,a4)end;turtlecraft.seeker.fill=function(a4)if a4==nil then a4=directions.down;if turtle.detectDown()and not turtle.detectUp()then a4=directions.up end end;E.write("fill",a4)local aT={move=turtle.up,detect=turtle.detectUp}local am={move=turtle.down,detect=turtle.detectDown,place=turtle.placeUp}if a4==directions.up then aT={move=turtle.down,detect=turtle.detectDown}am={move=turtle.up,detect=turtle.detectUp,place=turtle.placeDown}end;local step=function()for r,aU in pairs(aL)do aU()if turtle.back()then return true end end;return false end;turtlecraft.term.clear("Fill")turtlecraft.term.write(1,5,"Press Q to stop")turtlecraft.input.escapeOnKey(16,function()while true do turtlecraft.fuel.require(1)if not aT.detect()then aT.move()elseif step()then aP()turtle.place()else turtle.turnLeft()turtle.turnLeft()if am.detect()then turtlecraft.term.write(1,5,"I got stuck!")turtlecraft.term.write(1,6,"Press any key to continue")turtlecraft.input.readKey()return end;am.move()aP()am.place()end end end)E.complete()end;local aY,aZ=E.read()if aY~=nil then turtlecraft.seeker[aY](aZ)end end()turtlecraft.builder={}function()local a_=turtlecraft.directory.."project.data"local b0=turtlecraft.directory.."builder.data"local b1={}b1.data={}b1.load=function()if not fs.exists(a_)then return false end;local ak=fs.open(a_,"r").readAll()or""b1.data={}local b2=string.gmatch(ak,"[^,]+")for b3 in b2 do local b4={x=tonumber(b3),y=tonumber(b2()),z=tonumber(b2())}table.insert(b1.data,b4)end;return true end;b1.save=function()local ak=""for r,v in ipairs(b1.data)do ak=ak..v.x..","..v.y..","..v.z..","end;local G=fs.open(a_,"w")G.write(ak)G.close()end;b1.clear=function()b1.data={}fs.delete(a_)end;b1.load()local aY={}aY.isEnabled=function()return fs.exists(b0)end;aY.set=function(b5)local ak=fs.open(b0,"w")ak.write(b5.x..","..b5.y..","..b5.z)ak.close()end;aY.get=function()local ak=fs.open(b0,"r")local J=string.gmatch(ak.readAll(),"[^,]+")ak.close()return{x=tonumber(J()),y=tonumber(J()),z=tonumber(J())}end;aY.disable=function()fs.delete(b0)end;local b6={}b6.round=function(b7)if b7%1>=0.5 then return math.ceil(b7)else return math.floor(b7)end end;b6.plot=function(b8,aF)return{h=math.cos(math.rad(b8))*aF,v=math.sin(math.rad(b8))*aF}end;b6.measure=function(x,y,z)if x==nil then x=0 end;if y==nil then y=0 end;if z==nil then z=0 end;return math.sqrt(x*x+y*y+z*z)end;b6.angleStep=function(b9)return 45/b9/2 end;b6.rotateVector=function(b4,ba,bb,bc)if ba==nil then ba=0 end;if bb==nil then bb=0 end;if bc==nil then bc=0 end;if ba==0 and bb==0 and bc==0 then return end;if ba~=0 then local bd=math.cos(math.rad(ba))local be=math.sin(math.rad(ba))local bf=bd*b4.z-be*b4.y;local bg=be*b4.z+bd*b4.y;b4.z=bf;b4.y=bg end;if bb~=0 then local bh=math.cos(math.rad(bb))local bi=math.sin(math.rad(bb))local bj=bh*b4.x-bi*b4.z;local bk=bi*b4.x+bh*b4.z;b4.x=bj;b4.z=bk end;if bc~=0 then local bl=math.cos(math.rad(bc))local bm=math.sin(math.rad(bc))local bn=bl*b4.x-bm*b4.y;local bo=bm*b4.x+bl*b4.y;b4.x=bn;b4.y=bo end end;b6.scaleVector=function(b4,bp,bq,br)if bp==nil then bp=1 end;if bq==nil then bq=1 end;if br==nil then br=1 end;if bp==1 and bq==1 and br==1 then return end;b4.x=b4.x*bp;b4.y=b4.y*bq;b4.z=b4.z*br end;b6.roundVector=function(b4)b4.x=b6.round(b4.x)b4.y=b6.round(b4.y)b4.z=b6.round(b4.z)end;b6.line=function(a8,to)local bs={}local b4={x=to.x-a8.x,y=to.y-a8.y,z=to.z-a8.z}local bt=b6.measure(b4.x,b4.y,b4.z)for d=0,bt,0.5 do table.insert(bs,{x=a8.x+b4.x/bt*d,y=a8.y+b4.y/bt*d,z=a8.z+b4.z/bt*d})end;return bs end;b6.bounds=function(bs)local west=0;local east=0;local north=0;local south=0;local up=0;local down=0;for r,v in ipairs(bs)do if v.x<west then west=v.x end;if v.x>east then east=v.x end;if v.y>north then north=v.y end;if v.y<south then south=v.y end;if v.z>up then up=v.z end;if v.z<down then down=v.z end end;return north,south,east,west,up,down end;local bu={}bu.concat=function(bv,bw)local aK={}for r,v in ipairs(bv)do table.insert(aK,v)end;for r,v in ipairs(bw)do table.insert(aK,v)end;return aK end;bu.group=function(bx,by)local bz={}local bA={}for r,bB in ipairs(bx)do local bC=by(bB)if bA[bC]==nil then bA[bC]={}end;table.insert(bA[bC],bB)end;local bD={}for bC in pairs(bA)do table.insert(bD,bC)end;table.sort(bD)for r,bC in ipairs(bD)do table.insert(bz,bA[bC])end;return bz end;bu.extractNearestVector=function(bs,b4)if bs==nill or b4==nil or bs[1]==nil then return nil end;local as=0;local aF=nil;for r,compare in ipairs(bs)do local bE=b6.measure(compare.x-b4.x,compare.y-b4.y,compare.z-b4.z)if aF==nil or bE<aF then aF=bE;as=r end end;return table.remove(bs,as)end;bu.sortVectors=function(bs)local bz={}local bF=bu.group(bs,function(v)return v.z end)for bG,bH in ipairs(bF)do local bI={}local bJ=bu.group(bH,function(v)return v.y end)for bK,j in ipairs(bJ)do local bL=bu.group(j,function(v)return v.x end)for bM,i in ipairs(bL)do table.insert(bI,i[1])end end;if bI[1]~=nil then local b4=table.remove(bI,1)table.insert(bz,b4)while bI[1]~=nil do b4=bu.extractNearestVector(bI,b4)table.insert(bz,b4)end end end;return bz end;local bN={}bN.line=function(b9)return b6.line({x=-b9,y=0,z=0},{x=b9,y=0,z=0})end;bN.circle=function(b9)local bs={}local step=b6.angleStep(b9)for b8=0,360,step do local ah=b6.plot(b8,b9)table.insert(bs,{x=ah.h,y=ah.v,z=0})end;return bs end;bN.polygon=function(b9,bO)if bO<3 then return nil end;local bs={}local step=360/bO;local bP=nil;for b8=0,360,step do corner=b6.plot(b8,b9)if bP~=nil then bs=bu.concat(bs,b6.line({x=bP.h,y=bP.v,z=0},{x=corner.h,y=corner.v,z=0}))end;bP=corner end;return bs end;local bQ={}bQ.tube=function(b9,bR)local aK={}for z=-b9,b9 do for r,v in ipairs(bR)do table.insert(aK,{x=v.x,y=v.y,z=z})end end;return aK end;bQ.cone=function(b9,bR)local aK={}for z=-b9,b9 do local bS=1/b9*2*math.abs(z-b9)for r,v in ipairs(bR)do table.insert(aK,{x=v.x*bS,y=v.y*bS,z=z})end end;return aK end;bQ.sphere=function(b9,bR)local aK={}local step=b6.angleStep(b9)for b8=0,180,step do local bT=b6.plot(b8,b9)local z=bT.h;local bS=bT.v/b9;for r,v in ipairs(bR)do table.insert(aK,{x=v.x*bS,y=v.y*bS,z=z})end end;return aK end;bQ.torus=function(b9,bR)local aK={}local step=b6.angleStep(b9)local bU=0;for r,v in ipairs(bR)do if v.x<bU then bU=v.x end end;local bV=b9-bU;for r,v in ipairs(bR)do v.x=v.x-bV;table.insert(aK,v)end;for b8=0,360,step do for r,v in ipairs(bR)do local b4={x=v.x,y=v.y,z=v.z}b6.rotateVector(b4,0,b8,0)table.insert(aK,b4)end end;return aK end;local aP=function()local aO=0;while true do for r=2,16 do if turtle.getItemCount(r)>0 then sleep(aO)if turtle.getItemCount(r)>0 then turtle.select(r)return r end end end;aO=15;turtlecraft.term.clear("Inventory")turtlecraft.term.write(1,5,"Please add more inventory...")sleep(1)end end;local ap=function(b5)turtlecraft.term.clear("Build Project")turtlecraft.term.write(1,4,"Press Q to cancel")turtlecraft.input.escapeOnKey(16,function()local bW=false;local x,y,z,d=turtlecraft.position.get()for r,v in ipairs(b1.data)do local au={x=v.x+b5.x,y=v.y+b5.y,z=v.z+b5.z}if not bW then bW=au.x==x and au.y==y and au.z==z else turtlecraft.move.digTo(au.x,au.y,au.z)if turtle.detectDown()then turtle.digDown()end;aP()turtle.placeDown()end end end)aY.disable()end;turtlecraft.builder.clear=function()turtlecraft.term.clear("Delete Project")turtlecraft.term.write(1,4,"You will lose all stored data.")turtlecraft.term.write(1,5,"Are you sure? (y, n): ")if read()=="y"then b1.data={}b1.save()turtlecraft.term.clear("Delete Project")turtlecraft.term.write(1,4,"Project erased!")turtlecraft.input.readKey(5)else turtlecraft.term.clear("Delete Project")turtlecraft.term.write(1,4,"Erase cancelled!")turtlecraft.input.readKey(5)end end;turtlecraft.builder.stats=function()turtlecraft.term.clear("Project Info")local bX=table.getn(b1.data)if bX==0 then turtlecraft.term.write(1,4,"Your project is empty")turtlecraft.input.readKey(5)return end;local north,south,east,west,up,down=b6.bounds(b1.data)turtlecraft.term.write(1,4,"Block Count: "..bX)turtlecraft.term.write(1,5,math.abs(north).." blocks north.")turtlecraft.term.write(1,6,math.abs(south).." blocks south.")turtlecraft.term.write(1,7,math.abs(east).." blocks east.")turtlecraft.term.write(1,8,math.abs(west).." blocks west.")turtlecraft.term.write(1,9,math.abs(up).." blocks up.")turtlecraft.term.write(1,10,math.abs(down).." blocks down.")turtlecraft.input.readKey(15)end;turtlecraft.builder.start=function()if table.getn(b1.data)==0 then turtlecraft.term.write(1,4,"Your project is empty")sleep(5)return end;local start=b1.data[1]local x,y,z,d=turtlecraft.position.get()local b5={x=x,y=y,z=z}aY.set(b5)turtlecraft.move.digTo(start.x+b5.x,start.y+b5.y,start.z+b5.z)ap(b5)end;turtlecraft.builder.trim=function()turtlecraft.term.clear("Trim")turtlecraft.term.write(1,4,"This will allow you to trim off")turtlecraft.term.write(1,5,"blocks from the sides of your project.")local bY,bZ,b_,c0,c1,c2=b6.bounds(b1.data)turtlecraft.term.write(1,6,"How much from the north?")turtlecraft.term.write(1,7,"(0-"..math.abs(bY).."): ")local north=bY-math.max(0,math.min(math.abs(bY),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the south?")turtlecraft.term.write(1,7,"(0-"..math.abs(bZ).."): ")local south=bZ+math.max(0,math.min(math.abs(bZ),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the east?")turtlecraft.term.write(1,7,"(0-"..math.abs(b_).."): ")local east=b_-math.max(0,math.min(math.abs(b_),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the west?")turtlecraft.term.write(1,7,"(0-"..math.abs(c0).."): ")local west=c0+math.max(0,math.min(math.abs(c0),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the up?")turtlecraft.term.write(1,7,"(0-"..math.abs(c1).."): ")local up=c1-math.max(0,math.min(math.abs(c1),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the down?")turtlecraft.term.write(1,7,"(0-"..math.abs(c2).."): ")local down=c2+math.max(0,math.min(math.abs(c2),tonumber(read()or 0)))turtlecraft.term.clear("Trim")turtlecraft.term.write(1,4,"Calculating...")local aK={}for r,v in ipairs(b1.data)do if v.y<=north and v.y>=south and v.x<=east and v.x>=west and v.z<=up and v.z>=down then table.insert(aK,v)end end;b1.data=aK;b1.save()turtlecraft.term.clear("Trim")turtlecraft.term.write(1,4,"Trim complete!")turtlecraft.input.readKey(5)end;turtlecraft.builder.add=function()turtlecraft.term.clear("Add Shape")turtlecraft.term.write(1,4,"To create a shape you must select")turtlecraft.term.write(1,5,"how many sides you want your base")turtlecraft.term.write(1,6,"2D shape to be: (0 = circle, 1 = line)")turtlecraft.term.write(1,7,"Sides: ")local bO=tonumber(read()or 0)local c3=bN.circle;if bO==1 then c3=bN.line end;if bO>1 then c3=function(b9)return bN.polygon(b9,bO)end end;turtlecraft.term.clear("Radius")turtlecraft.term.write(1,4,"Now choose the radius of your base")turtlecraft.term.write(1,5,"shape. (Radius is from center to edge)")turtlecraft.term.write(1,6,"Radius: ")local b9=math.abs(tonumber(read()or 0))if b9==0 then return end;turtlecraft.term.clear("Extrude Shape")turtlecraft.term.write(1,4,"Now you must choose how to extrude your")turtlecraft.term.write(1,5,"2D shape into a 3D shape: ")turtlecraft.term.write(1,7,"1 = tube, 2 = cone, ")turtlecraft.term.write(1,8,"3 = sphere, 4 = torus")turtlecraft.term.write(1,9,"Enter nothing to keep this a 2D shape.")turtlecraft.term.write(1,10,"Extrusion: ")local c4={"tube","cone","sphere","torus"}local c5=read()or""local as=tonumber(c5 or 0)for r,v in ipairs(c4)do if as==r then c5=v;break end;if c5==v then break end end;local c6=function(b9,bN)return bN end;if bQ[c5]~=nil then c6=bQ[c5]end;local bN={}if c5=="torus"then turtlecraft.term.clear("Extrude Shape")turtlecraft.term.write(1,4,"I need a radius for your torus.")turtlecraft.term.write(1,5,"Radius: ")local c7=math.abs(tonumber(read()or 0))if c7==0 then return end;bN=c6(c7,c3(b9))else bN=c6(b9,c3(b9))end;local c8=1;local c9=1;local ca=1;turtlecraft.term.clear("Scale Shape")turtlecraft.term.write(1,4,"Would you like to squish your shape?")turtlecraft.term.write(1,5,"(y or n): ")if read()=="y"then turtlecraft.term.write(1,4,"Squish east-west...")turtlecraft.term.write(1,5,"(0 - 100): ")c8=math.max(0,math.min(100,tonumber(read()or 0)))/100;turtlecraft.term.write(1,4,"Squish north-south...")turtlecraft.term.write(1,5,"(0 - 100): ")c9=math.max(0,math.min(100,tonumber(read()or 0)))/100;turtlecraft.term.write(1,4,"Squish up-down...")turtlecraft.term.write(1,5,"(0 - 100): ")ca=math.max(0,math.min(100,tonumber(read()or 0)))/100 end;local cb=0;local cc=0;local cd=0;turtlecraft.term.clear("Rotate Shape")turtlecraft.term.write(1,4,"Would you like to turn your shape?")turtlecraft.term.write(1,5,"(y or n): ")if read()=="y"then turtlecraft.term.write(1,4,"Rotate east-west axis...")turtlecraft.term.write(1,5,"(0 - 360): ")cb=math.max(0,math.min(360,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Rotate north-south axis...")turtlecraft.term.write(1,5,"(0 - 360): ")cc=math.max(0,math.min(360,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Rotate up-down axis...")turtlecraft.term.write(1,5,"(0 - 360): ")cd=math.max(0,math.min(360,tonumber(read()or 0)))end;local ce=0;local cf=0;local cg=0;turtlecraft.term.clear("Offset Shape")turtlecraft.term.write(1,4,"Would you like to offset your shape?")turtlecraft.term.write(1,5,"(y or n): ")if read()=="y"then turtlecraft.term.write(1,4,"Offset east-west...")turtlecraft.term.write(1,5,"(-500 to 500): ")ce=math.max(-500,math.min(500,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Offset north-south...")turtlecraft.term.write(1,5,"(-500 to 500): ")cf=math.max(-500,math.min(500,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Offset up-down...")turtlecraft.term.write(1,5,"(-500 to 500): ")cg=math.max(-500,math.min(500,tonumber(read()or 0)))end;turtlecraft.term.clear("Generating Shape")turtlecraft.term.write(1,4,"Generating your shape...")for r,v in ipairs(bN)do b6.scaleVector(v,c8,c9,ca)b6.rotateVector(v,cb,cc,cd)v.x=v.x+ce;v.y=v.y+cf;v.z=v.z+cg;b6.roundVector(v)table.insert(b1.data,v)end;b1.data=bu.sortVectors(b1.data)b1.save()turtlecraft.term.clear("Add Shape")turtlecraft.term.write(1,4,"All done!")turtlecraft.input.readKey(5)end;if aY.isEnabled()then local b5=aY.get()ap(b5)end end()turtlecraft.help={}function()local ch=function()print("Press any key to read more...")turtlecraft.input.readKey()term.clear()term.setCursorPos(1,1)end;local ci=function(k)local n,o=term.getSize()term.clear()term.setCursorPos(1,1)local j=1;local cj=""local ck=string.gmatch(k,"[^\n]+")for cl in ck do local cm=string.gmatch(cl,"%S+")for cn in cm do local cn=cn.." "local co=string.len(cn)local cp=string.len(cj)if cp+co>=n-1 then print(cj)cj=""j=j+1;if j>=o-1 then ch()j=1 end end;cj=cj..cn end;print(cj)cj=""j=j+1;if j>=o-1 then ch()j=1 end end;ch()end;turtlecraft.help.general=function()local k="Turtlecraft is a menu-driven system that will help you utilize your turtle for various creating, digging, and collection functions.\n".."Select 'Dig functions' to excavate, fill/clear areas, or 'eat'.\n".."Select 'Build functions' to have your turtle help you create 2d and 3d shapes.\n".."There is a whole world of things you can make your turtle do. Turtlecraft will only help you with these few things.\n"ci(k)end;turtlecraft.help.dig=function()local k="Excavate: This will dig directly in front of the turtle's current position. ".."You will be able to specify how far forward, left, right, up, and down to dig. ".."The turtle will always try to unload directly behind it's start position when it is full. ".."It will also return to its start position for more fuel when it is empty. ".."If the turtle is unloaded or interrupted it will attempt to resume the next time it reloads ".."automatically.\n\n".."Eat: This will attempt to eat blocks starting from its current location. ".."This will not return when out of fuel or full of inventory. You will need to find ".."and satisfy the turtle's needs.\n".."WARNING: This can end up very bad if left unattended! DO NOT LEAVE UNATTENDED!\n".."Fill: This will attempt to fill an area using a circulating movement pattern. ".."This must be pre-loaded with blocks to unload and the turtle will not return ".."to reload or refuel. This will not dig or break blocks for any reason.\n".."WARNING: Your turtle is very likely to get stuck when filling in non-box shapes. ".."For non-box shapes always start the turtle in a small area to work its way into a large area ".."to avoid boxing itself in a corner. YOU MAY LOSE YOUR TURTLE. \n\n".."Empty: Much like 'Eat', this will attempt to empty an area, but will only eat one type of block. ".."The block that it will eat can either be pre-loaded into slot 2 (slot 1 is for fuel and ignored) ".."or the turtle will eat the first block that it finds above or below and then only continue to eat that type. ".."This uses a circulating movement pattern to find blocks and should probably not be left unattended. ".."This will not return to refuel or unload and will instead wait for you to fix whatever it needs ".."at whatever its current location.\n".."WARNING: This pattern may wander off. You should probably not leave this unattended."ci(k)end;turtlecraft.help.build=function()local k="Project: This is your virtual 3d 'canvas' that you are creating when adding shapes.\n".."Clear: This will erase all data from your project.\n".."Add: This will add a new shape (sphere, line, cube, etc...) to your project.\n".."Stats: This will calculate how many blocks and space your project requires.\n".."Send to monitor: This will attempt to render your current project on a monitor using ASCII art. ".."The bigger your monitor the better you will be able to see what your project should look like ".."when it is built.\n".."Start building: This will tell the turtle to start building your project. It will build from bottom ".."to top and will not return to refuel or reload. If the turtle runs out of fuel or blocks to build with ".."it must be given more supplies at its current position. If the turtle is unloaded or otherwise ".."interrupted it will attempt to resume building upon reload.\n".."WARNING: Build recovery is not perfect, so there is still a small chance that when the turtle ".."resumes building that it could get offset a square."ci(k)end end()turtlecraft.menu={}turtlecraft.menu[1]={l="Dig functions",action={}}turtlecraft.menu[1].action={}turtlecraft.menu[1].action[1]={l="Excavate",action=turtlecraft.excavate.start}turtlecraft.menu[1].action[2]={l="Eat Area",action=turtlecraft.seeker.eat}turtlecraft.menu[1].action[3]={l="Fill Area",action=turtlecraft.seeker.fill}turtlecraft.menu[1].action[4]={l="Empty Area",action=turtlecraft.seeker.unfill}turtlecraft.menu[1].action[5]={l="Halp meh!",action=turtlecraft.help.dig}turtlecraft.menu[2]={l="Build functions",action={}}turtlecraft.menu[2].action={}turtlecraft.menu[2].action[1]={l="Clear project",action=turtlecraft.builder.clear}turtlecraft.menu[2].action[2]={l="Add a shape",action=turtlecraft.builder.add}turtlecraft.menu[2].action[3]={l="Trim project",action=turtlecraft.builder.trim}turtlecraft.menu[2].action[4]={l="Project stats",action=turtlecraft.builder.stats}turtlecraft.menu[2].action[5]={l="Send to monitor",action=function()term.clear()print("Not Yet Implemented")read()end}turtlecraft.menu[2].action[6]={l="Start building",action=turtlecraft.builder.start}turtlecraft.menu[2].action[7]={l="Halp meh!",action=turtlecraft.help.build}turtlecraft.menu[3]={l="Halp meh!",action=turtlecraft.help.general}function()local af=turtlecraft.term;local cq=1;local cr={}table.insert(cr,turtlecraft.menu)local cs=af.write;local ct=function()local cu=cr[table.getn(cr)]return cu end;local cv=function()af.clear("Menu","** Use up/down and left/enter keys **")local menu=ct()for as,cu in ipairs(menu)do local k=cu.title;if as==cq then k=">"..k.."<"else k=" "..k end;af.scrolled(1,as,cq,k)end end;local cw=function()local menu=ct()local cu=menu[cq].action;if type(cu)=="function"then cu()else table.insert(cr,cu)end end;local cx=function()if table.getn(cr)>1 then cq=1;table.remove(cr)end end;local cy=function()local menu=ct()if cq<table.getn(menu)then cq=cq+1 end end;local cz=function()if cq>1 then cq=cq-1 end end;if not turtlecraft.position.isInSync()then term.clear()cs(1,1,"The turtle's position has gotten out of sync.")cs(1,2,"If there was a function in progress it has likely been cancelled.")cs(1,3,"Press any key to continue")local t,t,t,d=turtlecraft.position.get()turtlecraft.position.set(0,0,0,d)turtlecraft.input.readKey()end;while true do cv()sleep(0.01)local bC=turtlecraft.input.readKey()if bC==28 then cw()end;if bC==200 then cz()end;if bC==208 then cy()end;if bC==203 then cx()end end end()
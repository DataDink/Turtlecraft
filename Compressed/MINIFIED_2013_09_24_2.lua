--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\global.lua
if turtlecraft~=nil then error("A conflicting version of turtle craft exists or another script has registered 'turtlecraft'")end;turtlecraft={}turtlecraft.version=0.01;turtlecraft.directory="turtlecraft_data/"if not fs.exists("turtlecraft_data")then fs.makeDir("turtlecraft_data")end
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\utility.lua
turtlecraft.input={}turtlecraft.input.readKey=function(a)if a~=nil then os.startTimer(a)end;local b=""local c=0;repeat b,c=os.pullEvent()until b=="key"or b=="timer"if b=="timer"then return nil end;return c end;turtlecraft.input.escapeOnKey=function(d,e)local f=function()while true do local b,c=os.pullEvent("key")if c==d then return end end end;parallel.waitForAny(f,e)end;turtlecraft.term={}turtlecraft.term.write=function(g,h,i)term.setCursorPos(g,h)term.clearLine()term.write(i)end;turtlecraft.term.clear=function(j,k)term.clear()local l,m=term.getSize()local n="Turtlecraft v"..turtlecraft.version;if j~=nil then n=n.." - "..j end;turtlecraft.term.write(1,1,n)local o=""for p=1,l do o=o.."="end;turtlecraft.term.write(1,2,o)if k~=nil then turtlecraft.term.write(1,m,k)end end;turtlecraft.term.scrolled=function(g,h,q,i)local r,m=term.getSize()local s=math.max(0,q-m+1)local t=m-5;local u=3;local v=h-s;if v<1 or v>t then return end;turtlecraft.term.write(1,v+u,i)end;turtlecraft.term.notifyResume=function(w)if w==nil then w="previous function"end;turtlecraft.term.clear()turtlecraft.term.write(1,4,"Resuming: "..w)turtlecraft.term.write(1,5,"in 15 seconds.")turtlecraft.term.write(1,6,"Press any key to cancel.")local c=turtlecraft.input.readKey(15)turtlecraft.term.clear()return c==nil end
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\position.lua
turtlecraft.position={}turtlecraft.scope=function()local directions={north=270,south=90,west=180,east=0,up='up',down='down'}turtlecraft.position.directions=directions;local facings={}facings[0]=directions.south;facings[1]=directions.west;facings[2]=directions.north;facings[3]=directions.east;turtlecraft.position.facings=facings;local a={x=0,y=0,z=0,d=directions.north}local b={positionConfirmed=false,directionConfirmed=false,canSync=false,inSync=false}local c={path=turtlecraft.directory.."position.data"}c.read=function()local e={x=a.x,y=a.y,z=a.z,d=a.d,positionConfirmed=false,directionConfirmed=false}if not fs.exists(c.path)then return e end;local f=fs.open(c.path,"r")if f==nil then return e end;local g=f.readLine()local h=f.readLine()f.close()if g==nil then return e end;local i=string.gmatch(g,"[^,]+")local j={x=tonumber(i()),y=tonumber(i()),z=tonumber(i()),d=tonumber(i()),positionConfirmed=false,directionConfirmed=false}local k=tonumber(i())if h==nil then j.positionConfirmed=true;j.directionConfirmed=true;return j end;i=string.gmatch(h,"[^,]+")local l={x=tonumber(i()),y=tonumber(i()),z=tonumber(i()),d=tonumber(i())}if k>turtle.getFuelLevel()then j.positionConfirmed=true;j.directionConfirmed=true elseif k==turtle.getFuelLevel()then j.x=l.x;j.y=l.y;j.z=l.z;j.positionConfirmed=true;j.directionConfirmed=j.d==l.d end;return j end;c.write=function(j,l)local f=fs.open(c.path,"w")if f==nil then return false end;f.writeLine(j.x..","..j.y..","..j.z..","..j.d..","..turtle.getFuelLevel())if l~=nil then f.writeLine(l.x..","..l.y..","..l.z..","..l.d)end;f.close()return true end;b.getPeripheral=function(m)local n=peripheral.getNames()for o,p in pairs(n)do if peripheral.getType(p)==m then local q=peripheral.wrap(p)return q end end;return nil end;b.tryUpdateCustom=function()return false end;b.tryReadGps=function()local r=""if peripheral.getType("right")=="modem"then r="right"end;if peripheral.getType("left")=="modem"then r="left"end;if r==""then return nil end;rednet.open(r)if not rednet.isOpen(r)then return nil end;local x,z,y=gps.locate(10)return x,y,z end;b.tryUpdateGps=function()local x,y,z=b.tryReadGps()if x==nil then return false end;a.x=x;a.y=y;a.z=z;b.positionConfirmed=true;b.canSync=true;return true end;b.tryUpdateCompass=function()local s=b.getPeripheral("compass")if s==nil or s.getFacing==nil then return false end;a.d=facings[s.getFacing()]b.directionConfirmed=true;return true end;b.trySync=function()if b.directionConfirmed and b.positionConfirmed then return true end;if not b.canSync then return false end;for t=1,4 do if not turtle.detect()then break end;a.d=(a.d+90)%360;turtle.turnRight()end;if turtle.detect()then return false end;turtle.forward()local x=a.x;local y=a.y;local z=a.z;local d=a.d;if d==directions.north then y=y+1 end;if d==directions.south then y=y-1 end;if d==directions.east then x=x+1 end;if d==directions.west then x=x-1 end;local u,v,w=b.tryReadGps()if d==directions.north and u<x then d=directions.west end;if d==directions.south and u<x then d=directions.west end;if d==directions.east and u<x and v==y then d=directions.west end;if d==directions.north and u>x then d=directions.east end;if d==directions.south and u>x then d=directions.east end;if d==directions.west and u>x and v==y then d=directions.east end;if d==directions.north and v<y and u==x then d=directions.south end;if d==directions.west and v<y then d=directions.south end;if d==directions.east and v<y then d=directions.south end;if d==directions.south and v>y and u==x then d=directions.north end;if d==directions.west and v>y then d=directions.north end;if d==directions.east and v>y then d=directions.north end;turtle.back()a.d=d;c.write(a)return true end;a.init=function()local A=c.read()a.x=A.x;a.y=A.y;a.z=A.z;a.d=A.d;b.positionConfirmed=A.positionConfirmed;b.directionConfirmed=A.directionConfirmed;if not b.tryUpdateCustom()then b.tryUpdateGps()b.tryUpdateCompass()end;b.inSync=b.positionConfirmed and b.directionConfirmed or b.trySync()end;a.init()turtlecraft.position.isInSync=function()return b.inSync end;turtlecraft.position.syncTo=function(x,y,z,d)a.x=x;a.y=y;a.z=z;a.d=d;b.inSync=true end;turtlecraft.position.get=function()return a.x,a.y,a.z,a.d end;turtlecraft.position.set=function(x,y,z,d,B)if type(d)~="number"then d=a.d end;local l={x=a.x,y=a.y,z=a.z,d=a.d}local j={x=x,y=y,z=z,d=d}c.write(j,l)if B==nil or B()==false then c.write(l)return false end;c.write(j)a.x=x;a.y=y;a.z=z;a.d=d;return true end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\fuel.lua
turtlecraft.fuel={}turtlecraft.scope=function()local a={fuelSlot=1,fuelPerBurn=0,itemsPerBurn=1}a.getRefuelCount=function()return turtle.getItemCount(a.fuelSlot)end;a.burn=function()turtle.select(a.fuelSlot)local b=turtle.getFuelLevel()if not turtle.refuel(a.itemsPerBurn)then return false end;local c=turtle.getFuelLevel()a.fuelPerBurn=c-b;return true end;turtlecraft.fuel.estimateRemaining=function()local d=turtle.getFuelLevel()local e=a.getRefuelCount()local f=e*a.fuelPerBurn;return d+f end;turtlecraft.fuel.require=function(g)if g==nil then g=1 end;while turtle.getFuelLevel()<g do if not a.burn()then print("Turtle ran out of fuel! Please put more in slot 1")while not a.burn()do sleep(5)end end end end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\move.lua
turtlecraft.move={}turtlecraft.scope=function()local a={}local directions=turtlecraft.position.directions;a.face=function(b)if b==directions.up or b==directions.down then return true end;local c,d,e,f=turtlecraft.position.get()if f==b then return true end;if f%90~=0 then error("Facing directions must be multiples of 90 degrees")end;if(f+270)%360==b then turtlecraft.position.set(c,d,e,b,turtle.turnLeft)else while f~=b do f=(f+90)%360;turtlecraft.position.set(c,d,e,f,turtle.turnRight)end end;return true end;a.dig=function()return not turtle.detect()or turtle.dig()end;a.digUp=function()return not turtle.detectUp()or turtle.digUp()end;a.digDown=function()return not turtle.detectDown()or turtle.digDown()end;a.excavate=function()a.digUp()a.digDown()return a.dig()end;a.excavateUp=function()a.dig()a.digDown()return a.digUp()end;a.excavateDown=function()a.dig()a.digUp()return a.digDown()end;a.move=function(b,g,h,i)local move=turtle.forward;if b==directions.up then move=turtle.up end;if b==directions.down then move=turtle.down end;local c,d,e,f=turtlecraft.position.get()if b==directions.up then e=e+1 end;if b==directions.down then e=e-1 end;if b==directions.north then d=d+1 end;if b==directions.south then d=d-1 end;if b==directions.east then c=c+1 end;if b==directions.west then c=c-1 end;local j=function()turtlecraft.fuel.require(1)while not move()do if i~=nil and i(b)==false then return false end;sleep(.01)end;return true end;a.face(b)if g~=nil and g(b)==false then return false end;if turtlecraft.position.set(c,d,e,b,j)==false then return false end;if h~=nil and h(b)==false then return false end;return true end;a.repeatMove=function(k,to,l,m,g,h,i)local n=to-k;local b=l;if n<0 then b=m end;for o=1,math.abs(n)do if a.move(b,g,h,i)==false then return false end end;return true end;a.moveTo=function(c,d,e,g,h,i)local p,q,r,s=turtlecraft.position.get()if a.repeatMove(p,c,directions.east,directions.west,g,h,i)==false then return false end;if a.repeatMove(q,d,directions.north,directions.south,g,h,i)==false then return false end;if a.repeatMove(r,e,directions.up,directions.down,g,h,i)==false then return false end;return true end;turtlecraft.move.face=function(b)return a.face(b)end;turtlecraft.move.to=function(c,d,e,j)return a.moveTo(c,d,e,nil,j,nil)end;turtlecraft.move.digTo=function(c,d,e,j)local dig=function(b)if b==directions.up then return a.digUp()elseif b==directions.down then return a.digDown()else return a.dig()end end;return a.moveTo(c,d,e,dig,j,dig)end;turtlecraft.move.excavateTo=function(c,d,e,j)local dig=function(b)if b==directions.up then return a.excavateUp()elseif b==directions.down then return a.excavateDown()else return a.excavate()end end;return a.moveTo(c,d,e,dig,j,dig)end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\excavate.lua
turtlecraft.excavate={}turtlecraft.scope=function()local position=turtlecraft.position;local a=position.directions;local b=turtlecraft.term;local c={}local d={}local move={}d.path=turtlecraft.directory.."excavate.data"d.init=function(e,f,g,h,i)local j,k,l,m=position.get()d.home={j=j,k=k,l=l,m=(m+180)%360}d.step={j=1,k=1,l=-3}d.min={j=j,k=k,l=l-math.abs(i)+1}d.max={j=j,k=k,l=l+math.abs(h)-1}if m==a.north then d.max.y=d.max.y+math.abs(e)d.min.x=d.min.x-math.abs(f)d.max.x=d.max.x+math.abs(g)elseif m==a.south then d.min.y=d.min.y-math.abs(e)d.min.x=d.min.x-math.abs(g)d.max.x=d.max.x+math.abs(f)elseif m==a.east then d.max.x=d.max.x+math.abs(e)d.min.y=d.min.y-math.abs(g)d.max.y=d.max.y+math.abs(f)else d.min.x=d.min.x-math.abs(e)d.min.y=d.min.y-math.abs(f)d.max.y=d.max.y+math.abs(g)end;d.progress={j=d.min.x,k=d.min.y,l=d.max.z}end;d.update=function()local j,k,l,m=position.get()d.progress={j=j,k=k,l=l}local n=fs.open(d.path,"w")n.writeLine(d.home.x..","..d.home.y..","..d.home.z..","..d.home.d)n.writeLine(j..","..k..","..l)n.writeLine(d.min.x..","..d.min.y..","..d.min.z)n.writeLine(d.max.x..","..d.max.y..","..d.max.z)n.writeLine(d.step.x..","..d.step.y..","..d.step.z)n.close()end;d.reset=function()fs.delete(d.path)local j,k,l,m=position.get()d.home={j=j,k=k,l=l,m=(m+180)%360}d.progress={j=j,k=k,l=l}d.min={j=j,k=k,l=l}d.max={j=j,k=k,l=l}d.step={j=1,k=1,l=-3}end;d.recover=function()if not fs.exists(d.path)then return false end;local n=fs.open(d.path,"r")local o=n.readLine()local p=n.readLine()local q=n.readLine()local r=n.readLine()local s=n.readLine()n.close()if not position.isInSync()or o==nil or p==nil or q==nil or r==nil or s==nil then print("Warning: Unable to resume dig")return false end;local t="[^,]+"local u={o=o,p=p,min=q,max=r,step=s}for v,w in pairs(u)do local x=string.gmatch(w,t)if d[v]==nil then d[v]={}end;local y=d[v]y.x=tonumber(x()or 0)y.y=tonumber(x()or 0)y.z=tonumber(x()or 0)y.d=tonumber(x()or"")end;fs.delete(d.path)return true end;d.calcDistance=function(j,k,l)local z,A,B,C=position.get()local D=math.abs(z-j)local E=math.abs(A-k)local F=math.abs(B-l)return D+E+F+5 end;d.calcReturn=function()return d.calcDistance(d.home.x,d.home.y,d.home.z)end;c.calcRemainingSlots=function()local G=0;for H=2,16 do if turtle.getItemCount(H)==0 then G=G+1 end end;return G end;c.needsUnload=function()return c.calcRemainingSlots()==0 end;c.unload=function()turtlecraft.move.face(d.home.d)for H=2,16 do if turtle.getItemCount(H)>0 then turtle.select(H)if not turtle.drop()then error("Fatal Error: Can't unload inventory.")end end end end;move.home=function(I)turtlecraft.move.digTo(d.home.x,d.home.y,d.home.z)I()turtlecraft.move.face((d.home.d+180)%360)turtlecraft.move.digTo(d.progress.x,d.progress.y,d.progress.z)end;move.finish=function()fs.delete(d.path)turtlecraft.move.digTo(d.home.x,d.home.y,d.home.z)turtlecraft.move.face(d.home.d)c.unload()turtle.select(1)turtle.drop()turtlecraft.move.face((d.home.d+180)%360)d.reset()end;move.next=function()local J=d.calcDistance(d.progress.x,d.progress.y,d.progress.z)local K=d.calcReturn()local fuel=turtlecraft.fuel.estimateRemaining()if c.needsUnload()or fuel<=J or fuel<=K then move.home(function()local L=d.calcDistance(d.progress.x,d.progress.y,d.progress.z)turtlecraft.fuel.require(L)c.unload()end)end;if not turtlecraft.move.digTo(d.progress.x,d.progress.y,d.progress.z)then move.finish()return false end;local M=turtlecraft.move.excavateTo;local y={j=d.progress.x,k=d.progress.y,l=d.progress.z}y.x=y.x+d.step.x;if y.x>d.max.x or y.x<d.min.x then d.step.x=-d.step.x;y.x=y.x+d.step.x;y.y=d.progress.y+d.step.y;if y.y>d.max.y or y.y<d.min.y then d.step.y=-d.step.y;y.y=y.y+d.step.y;y.z=y.z+d.step.z;M=turtlecraft.move.digTo;turtle.digUp()if y.z==d.min.z-1 or y.z==d.min.z-2 then y.z=d.min.z end;if y.z<d.min.z then move.finish()return false end end end;if not M(y.x,y.y,y.z)then print("move failed")local j,k,l,m=turtlecraft.position.get()if j==d.progress.x and k==d.progress.y and l==d.progress.z then print("Unable to dig further")move.finish()return false end end;d.update()return true end;move.start=function(e,f,g,h,i)d.init(e,f,g,h,i)turtlecraft.term.write(1,5,"Press Q to cancel")turtlecraft.input.escapeOnKey(16,function()while move.next()do sleep(0.001)end end)d.reset()end;local N=function(j,k)term.setCursorPos(j,k)local O=tonumber(read()or"")if O==nil then return 0 end;return O end;if d.recover()then if not b.notifyResume("excavating")then b.clear("Excavate")b.write(1,5,"Excavate cancelled...")sleep(3)return end;b.clear("Excavate")b.write(1,5,"Resuming excavate...")term.setCursorPos(1,6)while move.next()do sleep(0.001)end end;turtlecraft.excavate.start=function()b.clear("Excavate")b.write(1,4,"How far forward?")local e=N(18,4)if e==0 then return false end;b.write(1,4,"How far left?")local f=N(15,4)b.write(1,4,"How far right?")local g=N(16,4)if f==0 and g==0 then return false end;b.write(1,4,"How far up?")local h=N(13,4)b.write(1,4,"How far down?")local i=N(15,4)if h==0 and i==0 then return false end;b.clear("Excavate")move.start(e,f,g,h,i)b.clear("Excavate")b.write(1,4,"Digging is complete.")b.write(1,5,"Press any key to continue.")term.setCursorPos(0,0)turtlecraft.input.readKey(10)end;turtlecraft.excavate.debug={}turtlecraft.excavate.debug.start=function(e,f,g,h,i)move.start(e,f,g,h,i)end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\seeker.lua
turtlecraft.seeker={}turtlecraft.scope=function()local a=turtlecraft.directory.."seeker.data"local b=function(c)turtle.turnRight()turtle.turnRight()local d=c()turtle.turnRight()turtle.turnRight()return d end;local e={up="up",down="down",forward="forward"}local f={turtle.turnRight,turtle.turnLeft,turtle.turnLeft,turtle.turnLeft}local g={}g.write=function(h,i)local j=fs.open(a,"w")j.write(h..","..i)j.close()end;g.complete=function()fs.delete(a)end;g.read=function()if not fs.exists(a)then return nil end;local j=fs.open(a,"r")local k=j.readLine()j.close()if k==nil then return nil end;local l=string.gmatch(k,"[^,]+")return l(),l()end;local m=function()local n=0;while true do for o=1,16 do if turtle.getItemCount(o)==0 then sleep(n)return end end;n=15;turtlecraft.term.clear("Inventory")turtlecraft.term.write(1,5,"Please unload me...")sleep(1)end end;local p=function()local n=0;while true do for o=2,16 do if turtle.getItemCount(o)>0 then sleep(n)if turtle.getItemCount(o)>0 then turtle.select(o)return o end end end;n=15;turtlecraft.term.clear("Inventory")turtlecraft.term.write(1,5,"Please add more inventory...")sleep(1)end end;local eat=function(compare,i)if i==nil then i=e.down;if turtle.detectUp()and not turtle.detectDown()then i=e.up end end;if compare and turtle.getItemCount(2)==0 then turtle.select(2)turtlecraft.fuel.require(1)if turtle.detectUp()then turtle.digUp()turtle.up()elseif turtle.detectDown()then turtle.digDown()turtle.down()else turtlecraft.term.clear()turtlecraft.term.write(1,5,"I need a sample block to unfill with.")turtlecraft.input.readKey(5)return end;g.write("unfill",i)else g.write("eat",i)end;local q=turtle.detectUp;local r=turtle.detectDown;local s=turtle.detect;if compare then q=function()turtle.select(2)return turtle.compareUp()end;r=function()turtle.select(2)return turtle.compareDown()end;s=function()turtle.select(2)return turtle.compare()end end;local t={move=turtle.up,detect=q,dig=turtle.digUp}local u={move=turtle.down,detect=r,dig=turtle.digDown}if i==e.up then t={move=turtle.down,detect=r,dig=turtle.digDown}u={move=turtle.up,detect=q,dig=turtle.digUp}end;local v=function()for o,w in pairs(f)do w()if s()then return true end end;return false end;local x=function()t.move()for y=1,3 do for z=1,4 do turtlecraft.fuel.require(2)turtle.forward()turtle.forward()if t.detect()or u.detect()or v()then return true end;turtle.turnLeft()end;u.move()end;return false end;turtlecraft.term.clear("Munch Munch")turtlecraft.term.write(1,5,"Press Q to stop")turtlecraft.input.escapeOnKey(16,function()while true do turtlecraft.fuel.require(1)m()if t.detect()then t.dig()t.move()elseif v()then while s()and turtle.dig()do sleep(0.5)end;turtle.forward()elseif u.detect()then while u.detect()and u.dig()do sleep(0.5)end;u.move()elseif not x()then turtlecraft.term.clear("All Gone?")turtlecraft.term.write(1,5,"I got lost!")turtlecraft.input.readKey(10)return end end end)g.complete()end;turtlecraft.seeker.eat=function(i)eat(false,i)end;turtlecraft.seeker.unfill=function(i)eat(true,i)end;turtlecraft.seeker.fill=function(i)if i==nil then i=e.down;if turtle.detectDown()and not turtle.detectUp()then i=e.up end end;g.write("fill",i)local t={move=turtle.up,detect=turtle.detectUp}local u={move=turtle.down,detect=turtle.detectDown,place=turtle.placeUp}if i==e.up then t={move=turtle.down,detect=turtle.detectDown}u={move=turtle.up,detect=turtle.detectUp,place=turtle.placeDown}end;local v=function()for o,w in pairs(f)do w()if turtle.back()then return true end end;return false end;turtlecraft.term.clear("Fill")turtlecraft.term.write(1,5,"Press Q to stop")turtlecraft.input.escapeOnKey(16,function()while true do turtlecraft.fuel.require(1)if not t.detect()then t.move()elseif v()then p()turtle.place()else turtle.turnLeft()turtle.turnLeft()if u.detect()then turtlecraft.term.write(1,5,"I got stuck!")turtlecraft.term.write(1,6,"Press any key to continue")turtlecraft.input.readKey()return end;u.move()p()u.place()end end end)g.complete()end;local A,B=g.read()if A~=nil then turtlecraft.seeker[A](B)end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\builder.lua
turtlecraft.builder={}turtlecraft.scope=function()local a=turtlecraft.directory.."project.data"local b=turtlecraft.directory.."builder.data"local c={}c.data={}c.load=function()if not fs.exists(a)then return false end;local d=fs.open(a,"r").readAll()or""c.data={}local e=string.gmatch(d,"[^,]+")for f in e do local g={x=tonumber(f),y=tonumber(e()),z=tonumber(e())}table.insert(c.data,g)end;return true end;c.save=function()local d=""for i,v in ipairs(c.data)do d=d..v.x..","..v.y..","..v.z..","end;local j=fs.open(a,"w")j.write(d)j.close()end;c.clear=function()c.data={}fs.delete(a)end;c.load()local k={}k.isEnabled=function()return fs.exists(b)end;k.set=function(l)local d=fs.open(b,"w")d.write(l.x..","..l.y..","..l.z)d.close()end;k.get=function()local d=fs.open(b,"r")local m=string.gmatch(d.readAll(),"[^,]+")d.close()return{x=tonumber(m()),y=tonumber(m()),z=tonumber(m())}end;k.disable=function()fs.delete(b)end;local n={}n.round=function(o)if o%1>=0.5 then return math.ceil(o)else return math.floor(o)end end;n.plot=function(p,q)return{h=math.cos(math.rad(p))*q,v=math.sin(math.rad(p))*q}end;n.measure=function(x,y,z)if x==nil then x=0 end;if y==nil then y=0 end;if z==nil then z=0 end;return math.sqrt(x*x+y*y+z*z)end;n.angleStep=function(r)return 45/r/2 end;n.rotateVector=function(g,s,t,u)if s==nil then s=0 end;if t==nil then t=0 end;if u==nil then u=0 end;if s==0 and t==0 and u==0 then return end;if s~=0 then local w=math.cos(math.rad(s))local A=math.sin(math.rad(s))local B=w*g.z-A*g.y;local C=A*g.z+w*g.y;g.z=B;g.y=C end;if t~=0 then local D=math.cos(math.rad(t))local E=math.sin(math.rad(t))local F=D*g.x-E*g.z;local G=E*g.x+D*g.z;g.x=F;g.z=G end;if u~=0 then local H=math.cos(math.rad(u))local I=math.sin(math.rad(u))local J=H*g.x-I*g.y;local K=I*g.x+H*g.y;g.x=J;g.y=K end end;n.scaleVector=function(g,L,M,N)if L==nil then L=1 end;if M==nil then M=1 end;if N==nil then N=1 end;if L==1 and M==1 and N==1 then return end;g.x=g.x*L;g.y=g.y*M;g.z=g.z*N end;n.roundVector=function(g)g.x=n.round(g.x)g.y=n.round(g.y)g.z=n.round(g.z)end;n.line=function(O,P)local Q={}local g={x=P.x-O.x,y=P.y-O.y,z=P.z-O.z}local R=n.measure(g.x,g.y,g.z)for S=0,R,0.5 do table.insert(Q,{x=O.x+g.x/R*S,y=O.y+g.y/R*S,z=O.z+g.z/R*S})end;return Q end;n.bounds=function(Q)local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;for i,v in ipairs(Q)do if v.x<T then T=v.x end;if v.x>U then U=v.x end;if v.y>V then V=v.y end;if v.y<W then W=v.y end;if v.z>X then X=v.z end;if v.z<Y then Y=v.z end end;return V,W,U,T,X,Y end;local Z={}Z.concat=function(_,a0)local a1={}for i,v in ipairs(_)do table.insert(a1,v)end;for i,v in ipairs(a0)do table.insert(a1,v)end;return a1 end;Z.group=function(a2,a3)local a4={}local a5={}for i,a6 in ipairs(a2)do local a7=a3(a6)if a5[a7]==nil then a5[a7]={}end;table.insert(a5[a7],a6)end;local a8={}for a7 in pairs(a5)do table.insert(a8,a7)end;table.sort(a8)for i,a7 in ipairs(a8)do table.insert(a4,a5[a7])end;return a4 end;Z.extractNearestVector=function(Q,g)if Q==nill or g==nil or Q[1]==nil then return nil end;local a9=0;local q=nil;for i,aa in ipairs(Q)do local ab=n.measure(aa.x-g.x,aa.y-g.y,aa.z-g.z)if q==nil or ab<q then q=ab;a9=i end end;return table.remove(Q,a9)end;Z.sortVectors=function(Q)local a4={}local ac=Z.group(Q,function(v)return v.z end)for ad,ae in ipairs(ac)do local af={}local ag=Z.group(ae,function(v)return v.y end)for ah,ai in ipairs(ag)do local aj=Z.group(ai,function(v)return v.x end)for ak,al in ipairs(aj)do table.insert(af,al[1])end end;if af[1]~=nil then local g=table.remove(af,1)table.insert(a4,g)while af[1]~=nil do g=Z.extractNearestVector(af,g)table.insert(a4,g)end end end;return a4 end;local am={}am.line=function(r)return n.line({x=-r,y=0,z=0},{x=r,y=0,z=0})end;am.circle=function(r)local Q={}local an=n.angleStep(r)for p=0,360,an do local ao=n.plot(p,r)table.insert(Q,{x=ao.h,y=ao.v,z=0})end;return Q end;am.polygon=function(r,ap)if ap<3 then return nil end;local Q={}local an=360/ap;local aq=nil;for p=0,360,an do corner=n.plot(p,r)if aq~=nil then Q=Z.concat(Q,n.line({x=aq.h,y=aq.v,z=0},{x=corner.h,y=corner.v,z=0}))end;aq=corner end;return Q end;local ar={}ar.tube=function(r,as)local a1={}for z=-r,r do for i,v in ipairs(as)do table.insert(a1,{x=v.x,y=v.y,z=z})end end;return a1 end;ar.cone=function(r,as)local a1={}for z=-r,r do local at=1/r*2*math.abs(z-r)for i,v in ipairs(as)do table.insert(a1,{x=v.x*at,y=v.y*at,z=z})end end;return a1 end;ar.sphere=function(r,as)local a1={}local an=n.angleStep(r)for p=0,180,an do local au=n.plot(p,r)local z=au.h;local at=au.v/r;for i,v in ipairs(as)do table.insert(a1,{x=v.x*at,y=v.y*at,z=z})end end;return a1 end;ar.torus=function(r,as)local a1={}local an=n.angleStep(r)local av=0;for i,v in ipairs(as)do if v.x<av then av=v.x end end;local aw=r-av;for i,v in ipairs(as)do v.x=v.x-aw;table.insert(a1,v)end;for p=0,360,an do for i,v in ipairs(as)do local g={x=v.x,y=v.y,z=v.z}n.rotateVector(g,0,p,0)table.insert(a1,g)end end;return a1 end;local ax=function()local ay=0;while true do for i=2,16 do if turtle.getItemCount(i)>0 then sleep(ay)if turtle.getItemCount(i)>0 then turtle.select(i)return i end end end;ay=15;turtlecraft.term.clear("Inventory")turtlecraft.term.write(1,5,"Please add more inventory...")sleep(1)end end;local az=function(l)turtlecraft.term.clear("Build Project")turtlecraft.term.write(1,4,"Press Q to cancel")turtlecraft.input.escapeOnKey(16,function()local aA=false;local x,y,z,S=turtlecraft.position.get()for i,v in ipairs(c.data)do local aB={x=v.x+l.x,y=v.y+l.y,z=v.z+l.z}if not aA then aA=aB.x==x and aB.y==y and aB.z==z else turtlecraft.move.digTo(aB.x,aB.y,aB.z)if turtle.detectDown()then turtle.digDown()end;ax()turtle.placeDown()end end end)k.disable()end;turtlecraft.builder.clear=function()turtlecraft.term.clear("Delete Project")turtlecraft.term.write(1,4,"You will lose all stored data.")turtlecraft.term.write(1,5,"Are you sure? (y, n): ")if read()=="y"then c.data={}c.save()turtlecraft.term.clear("Delete Project")turtlecraft.term.write(1,4,"Project erased!")turtlecraft.input.readKey(5)else turtlecraft.term.clear("Delete Project")turtlecraft.term.write(1,4,"Erase cancelled!")turtlecraft.input.readKey(5)end end;turtlecraft.builder.stats=function()turtlecraft.term.clear("Project Info")local aC=table.getn(c.data)if aC==0 then turtlecraft.term.write(1,4,"Your project is empty")turtlecraft.input.readKey(5)return end;local V,W,U,T,X,Y=n.bounds(c.data)turtlecraft.term.write(1,4,"Block Count: "..aC)turtlecraft.term.write(1,5,math.abs(V).." blocks north.")turtlecraft.term.write(1,6,math.abs(W).." blocks south.")turtlecraft.term.write(1,7,math.abs(U).." blocks east.")turtlecraft.term.write(1,8,math.abs(T).." blocks west.")turtlecraft.term.write(1,9,math.abs(X).." blocks up.")turtlecraft.term.write(1,10,math.abs(Y).." blocks down.")turtlecraft.input.readKey(15)end;turtlecraft.builder.start=function()if table.getn(c.data)==0 then turtlecraft.term.write(1,4,"Your project is empty")sleep(5)return end;local start=c.data[1]local x,y,z,S=turtlecraft.position.get()local l={x=x,y=y,z=z}k.set(l)turtlecraft.move.digTo(start.x+l.x,start.y+l.y,start.z+l.z)az(l)end;turtlecraft.builder.trim=function()turtlecraft.term.clear("Trim")turtlecraft.term.write(1,4,"This will allow you to trim off")turtlecraft.term.write(1,5,"blocks from the sides of your project.")local aD,aE,aF,aG,aH,aI=n.bounds(c.data)turtlecraft.term.write(1,6,"How much from the north?")turtlecraft.term.write(1,7,"(0-"..math.abs(aD).."): ")local V=aD-math.max(0,math.min(math.abs(aD),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the south?")turtlecraft.term.write(1,7,"(0-"..math.abs(aE).."): ")local W=aE+math.max(0,math.min(math.abs(aE),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the east?")turtlecraft.term.write(1,7,"(0-"..math.abs(aF).."): ")local U=aF-math.max(0,math.min(math.abs(aF),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the west?")turtlecraft.term.write(1,7,"(0-"..math.abs(aG).."): ")local T=aG+math.max(0,math.min(math.abs(aG),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the up?")turtlecraft.term.write(1,7,"(0-"..math.abs(aH).."): ")local X=aH-math.max(0,math.min(math.abs(aH),tonumber(read()or 0)))turtlecraft.term.write(1,6,"How much from the down?")turtlecraft.term.write(1,7,"(0-"..math.abs(aI).."): ")local Y=aI+math.max(0,math.min(math.abs(aI),tonumber(read()or 0)))turtlecraft.term.clear("Trim")turtlecraft.term.write(1,4,"Calculating...")local a1={}for i,v in ipairs(c.data)do if v.y<=V and v.y>=W and v.x<=U and v.x>=T and v.z<=X and v.z>=Y then table.insert(a1,v)end end;c.data=a1;c.save()turtlecraft.term.clear("Trim")turtlecraft.term.write(1,4,"Trim complete!")turtlecraft.input.readKey(5)end;turtlecraft.builder.add=function()turtlecraft.term.clear("Add Shape")turtlecraft.term.write(1,4,"To create a shape you must select")turtlecraft.term.write(1,5,"how many sides you want your base")turtlecraft.term.write(1,6,"2D shape to be: (0 = circle, 1 = line)")turtlecraft.term.write(1,7,"Sides: ")local ap=tonumber(read()or 0)local aJ=am.circle;if ap==1 then aJ=am.line end;if ap>1 then aJ=function(r)return am.polygon(r,ap)end end;turtlecraft.term.clear("Radius")turtlecraft.term.write(1,4,"Now choose the radius of your base")turtlecraft.term.write(1,5,"shape. (Radius is from center to edge)")turtlecraft.term.write(1,6,"Radius: ")local r=math.abs(tonumber(read()or 0))if r==0 then return end;turtlecraft.term.clear("Extrude Shape")turtlecraft.term.write(1,4,"Now you must choose how to extrude your")turtlecraft.term.write(1,5,"2D shape into a 3D shape: ")turtlecraft.term.write(1,7,"1 = tube, 2 = cone, ")turtlecraft.term.write(1,8,"3 = sphere, 4 = torus")turtlecraft.term.write(1,9,"Enter nothing to keep this a 2D shape.")turtlecraft.term.write(1,10,"Extrusion: ")local aK={"tube","cone","sphere","torus"}local aL=read()or""local a9=tonumber(aL or 0)for i,v in ipairs(aK)do if a9==i then aL=v;break end;if aL==v then break end end;local aM=function(r,am)return am end;if ar[aL]~=nil then aM=ar[aL]end;local am={}if aL=="torus"then turtlecraft.term.clear("Extrude Shape")turtlecraft.term.write(1,4,"I need a radius for your torus.")turtlecraft.term.write(1,5,"Radius: ")local aN=math.abs(tonumber(read()or 0))if aN==0 then return end;am=aM(aN,aJ(r))else am=aM(r,aJ(r))end;local aO=1;local aP=1;local aQ=1;turtlecraft.term.clear("Scale Shape")turtlecraft.term.write(1,4,"Would you like to squish your shape?")turtlecraft.term.write(1,5,"(y or n): ")if read()=="y"then turtlecraft.term.write(1,4,"Squish east-west...")turtlecraft.term.write(1,5,"(0 - 100): ")aO=math.max(0,math.min(100,tonumber(read()or 0)))/100;turtlecraft.term.write(1,4,"Squish north-south...")turtlecraft.term.write(1,5,"(0 - 100): ")aP=math.max(0,math.min(100,tonumber(read()or 0)))/100;turtlecraft.term.write(1,4,"Squish up-down...")turtlecraft.term.write(1,5,"(0 - 100): ")aQ=math.max(0,math.min(100,tonumber(read()or 0)))/100 end;local aR=0;local aS=0;local aT=0;turtlecraft.term.clear("Rotate Shape")turtlecraft.term.write(1,4,"Would you like to turn your shape?")turtlecraft.term.write(1,5,"(y or n): ")if read()=="y"then turtlecraft.term.write(1,4,"Rotate east-west axis...")turtlecraft.term.write(1,5,"(0 - 360): ")aR=math.max(0,math.min(360,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Rotate north-south axis...")turtlecraft.term.write(1,5,"(0 - 360): ")aS=math.max(0,math.min(360,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Rotate up-down axis...")turtlecraft.term.write(1,5,"(0 - 360): ")aT=math.max(0,math.min(360,tonumber(read()or 0)))end;local aU=0;local aV=0;local aW=0;turtlecraft.term.clear("Offset Shape")turtlecraft.term.write(1,4,"Would you like to offset your shape?")turtlecraft.term.write(1,5,"(y or n): ")if read()=="y"then turtlecraft.term.write(1,4,"Offset east-west...")turtlecraft.term.write(1,5,"(-500 to 500): ")aU=math.max(-500,math.min(500,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Offset north-south...")turtlecraft.term.write(1,5,"(-500 to 500): ")aV=math.max(-500,math.min(500,tonumber(read()or 0)))turtlecraft.term.write(1,4,"Offset up-down...")turtlecraft.term.write(1,5,"(-500 to 500): ")aW=math.max(-500,math.min(500,tonumber(read()or 0)))end;turtlecraft.term.clear("Generating Shape")turtlecraft.term.write(1,4,"Generating your shape...")for i,v in ipairs(am)do n.scaleVector(v,aO,aP,aQ)n.rotateVector(v,aR,aS,aT)v.x=v.x+aU;v.y=v.y+aV;v.z=v.z+aW;n.roundVector(v)table.insert(c.data,v)end;c.data=Z.sortVectors(c.data)c.save()turtlecraft.term.clear("Add Shape")turtlecraft.term.write(1,4,"All done!")turtlecraft.input.readKey(5)end;if k.isEnabled()then local l=k.get()az(l)end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\help.lua
turtlecraft.help={}turtlecraft.scope=function()local a=function()print("Press any key to read more...")turtlecraft.input.readKey()term.clear()term.setCursorPos(1,1)end;local b=function(c)local d,e=term.getSize()term.clear()term.setCursorPos(1,1)local f=1;local g=""local h=string.gmatch(c,"[^\n]+")for i in h do local j=string.gmatch(i,"%S+")for k in j do local k=k.." "local l=string.len(k)local m=string.len(g)if m+l>=d-1 then print(g)g=""f=f+1;if f>=e-1 then a()f=1 end end;g=g..k end;print(g)g=""f=f+1;if f>=e-1 then a()f=1 end end;a()end;turtlecraft.help.general=function()local c="Turtlecraft is a menu-driven system that will help you utilize your turtle for various creating, digging, and collection functions.\n".."Select 'Dig functions' to excavate, fill/clear areas, or 'eat'.\n".."Select 'Build functions' to have your turtle help you create 2d and 3d shapes.\n".."There is a whole world of things you can make your turtle do. Turtlecraft will only help you with these few things.\n"b(c)end;turtlecraft.help.dig=function()local c="Excavate: This will dig directly in front of the turtle's current position. ".."You will be able to specify how far forward, left, right, up, and down to dig. ".."The turtle will always try to unload directly behind it's start position when it is full. ".."It will also return to its start position for more fuel when it is empty. ".."If the turtle is unloaded or interrupted it will attempt to resume the next time it reloads ".."automatically.\n\n".."Eat: This will attempt to eat blocks starting from its current location. ".."This will not return when out of fuel or full of inventory. You will need to find ".."and satisfy the turtle's needs.\n".."WARNING: This can end up very bad if left unattended! DO NOT LEAVE UNATTENDED!\n".."Fill: This will attempt to fill an area using a circulating movement pattern. ".."This must be pre-loaded with blocks to unload and the turtle will not return ".."to reload or refuel. This will not dig or break blocks for any reason.\n".."WARNING: Your turtle is very likely to get stuck when filling in non-box shapes. ".."For non-box shapes always start the turtle in a small area to work its way into a large area ".."to avoid boxing itself in a corner. YOU MAY LOSE YOUR TURTLE. \n\n".."Empty: Much like 'Eat', this will attempt to empty an area, but will only eat one type of block. ".."The block that it will eat can either be pre-loaded into slot 2 (slot 1 is for fuel and ignored) ".."or the turtle will eat the first block that it finds above or below and then only continue to eat that type. ".."This uses a circulating movement pattern to find blocks and should probably not be left unattended. ".."This will not return to refuel or unload and will instead wait for you to fix whatever it needs ".."at whatever its current location.\n".."WARNING: This pattern may wander off. You should probably not leave this unattended."b(c)end;turtlecraft.help.build=function()local c="Project: This is your virtual 3d 'canvas' that you are creating when adding shapes.\n".."Clear: This will erase all data from your project.\n".."Add: This will add a new shape (sphere, line, cube, etc...) to your project.\n".."Stats: This will calculate how many blocks and space your project requires.\n".."Send to monitor: This will attempt to render your current project on a monitor using ASCII art. ".."The bigger your monitor the better you will be able to see what your project should look like ".."when it is built.\n".."Start building: This will tell the turtle to start building your project. It will build from bottom ".."to top and will not return to refuel or reload. If the turtle runs out of fuel or blocks to build with ".."it must be given more supplies at its current position. If the turtle is unloaded or otherwise ".."interrupted it will attempt to resume building upon reload.\n".."WARNING: Build recovery is not perfect, so there is still a small chance that when the turtle ".."resumes building that it could get offset a square."b(c)end end;turtlecraft.scope()
--C:\Users\MNelson\Documents\GitHub\Turtlecraft\Source\menu.lua
turtlecraft.menu={}turtlecraft.menu[1]={title="Dig functions",action={}}turtlecraft.menu[1].action={}turtlecraft.menu[1].action[1]={title="Excavate",action=turtlecraft.excavate.start}turtlecraft.menu[1].action[2]={title="Eat Area",action=turtlecraft.seeker.eat}turtlecraft.menu[1].action[3]={title="Fill Area",action=turtlecraft.seeker.fill}turtlecraft.menu[1].action[4]={title="Empty Area",action=turtlecraft.seeker.unfill}turtlecraft.menu[1].action[5]={title="Halp meh!",action=turtlecraft.help.dig}turtlecraft.menu[2]={title="Build functions",action={}}turtlecraft.menu[2].action={}turtlecraft.menu[2].action[1]={title="Clear project",action=turtlecraft.builder.clear}turtlecraft.menu[2].action[2]={title="Add a shape",action=turtlecraft.builder.add}turtlecraft.menu[2].action[3]={title="Trim project",action=turtlecraft.builder.trim}turtlecraft.menu[2].action[4]={title="Project stats",action=turtlecraft.builder.stats}turtlecraft.menu[2].action[5]={title="Send to monitor",action=function()term.clear()print("Not Yet Implemented")read()end}turtlecraft.menu[2].action[6]={title="Start building",action=turtlecraft.builder.start}turtlecraft.menu[2].action[7]={title="Halp meh!",action=turtlecraft.help.build}turtlecraft.menu[3]={title="Halp meh!",action=turtlecraft.help.general}turtlecraft.scope=function()local a=turtlecraft.term;local b=1;local c={}table.insert(c,turtlecraft.menu)local d=a.write;local e=function()local f=c[table.getn(c)]return f end;local g=function()a.clear("Menu","** Use up/down and left/enter keys **")local menu=e()for h,f in ipairs(menu)do local i=f.title;if h==b then i=">"..i.."<"else i=" "..i end;a.scrolled(1,h,b,i)end end;local j=function()local menu=e()local f=menu[b].action;if type(f)=="function"then f()else table.insert(c,f)end end;local k=function()if table.getn(c)>1 then b=1;table.remove(c)end end;local l=function()local menu=e()if b<table.getn(menu)then b=b+1 end end;local m=function()if b>1 then b=b-1 end end;if not turtlecraft.position.isInSync()then term.clear()d(1,1,"The turtle's position has gotten out of sync.")d(1,2,"If there was a function in progress it has likely been cancelled.")d(1,3,"Press any key to continue")local n,n,n,o=turtlecraft.position.get()turtlecraft.position.set(0,0,0,o)turtlecraft.input.readKey()end;while true do g()sleep(0.01)local p=turtlecraft.input.readKey()if p==28 then j()end;if p==200 then m()end;if p==208 then l()end;if p==203 then k()end end end;turtlecraft.scope()
